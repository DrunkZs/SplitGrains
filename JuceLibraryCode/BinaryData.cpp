/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

namespace BinaryData
{

//================== Cholesky ==================
static const unsigned char temp_binary_data_0[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_CHOLESKY_MODULE_H\r\n"
"#define EIGEN_CHOLESKY_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"#include \"Jacobi\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \\defgroup Cholesky_Module Cholesky module\r\n"
"  *\r\n"
"  *\r\n"
"  *\r\n"
"  * This module provides two variants of the Cholesky decomposition for selfadjoint (hermitian) matrices.\r\n"
"  * Those decompositions are also accessible via the following methods:\r\n"
"  *  - MatrixBase::llt()\r\n"
"  *  - MatrixBase::ldlt()\r\n"
"  *  - SelfAdjointView::llt()\r\n"
"  *  - SelfAdjointView::ldlt()\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/Cholesky>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/Cholesky/LLT.h\"\r\n"
"#include \"src/Cholesky/LDLT.h\"\r\n"
"#ifdef EIGEN_USE_LAPACKE\r\n"
"#ifdef EIGEN_USE_MKL\r\n"
"#include \"mkl_lapacke.h\"\r\n"
"#else\r\n"
"#include \"src/misc/lapacke.h\"\r\n"
"#endif\r\n"
"#include \"src/Cholesky/LLT_LAPACKE.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_CHOLESKY_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* Cholesky = (const char*) temp_binary_data_0;

//================== CholmodSupport ==================
static const unsigned char temp_binary_data_1[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_CHOLMODSUPPORT_MODULE_H\r\n"
"#define EIGEN_CHOLMODSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"extern \"C\" {\r\n"
"  #include <cholmod.h>\r\n"
"}\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup CholmodSupport_Module CholmodSupport module\r\n"
"  *\r\n"
"  * This module provides an interface to the Cholmod library which is part of the <a href=\"http://www.suitesparse.com\">suitesparse</a> package.\r\n"
"  * It provides the two following main factorization classes:\r\n"
"  * - class CholmodSupernodalLLT: a supernodal LLT Cholesky factorization.\r\n"
"  * - class CholmodDecomposiiton: a general L(D)LT Cholesky factorization with automatic or explicit runtime selection of the underlying factorization method (supernodal or simplicial).\r\n"
"  *\r\n"
"  * For the sake of completeness, this module also propose the two following classes:\r\n"
"  * - class CholmodSimplicialLLT\r\n"
"  * - class CholmodSimplicialLDLT\r\n"
"  * Note that these classes does not bring any particular advantage compared to the built-in\r\n"
"  * SimplicialLLT and SimplicialLDLT factorization classes.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/CholmodSupport>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In order to use this module, the cholmod headers must be accessible from the include paths, and your binary must be linked to the cholmod library and its dependencies.\r\n"
"  * The dependencies depend on how cholmod has been compiled.\r\n"
"  * For a cmake based project, you can use our FindCholmod.cmake module to help you in this task.\r\n"
"  *\r\n"
"  */\r\n"
"\r\n"
"#include \"src/CholmodSupport/CholmodSupport.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_CHOLMODSUPPORT_MODULE_H\r\n"
"\r\n";

const char* CholmodSupport = (const char*) temp_binary_data_1;

//================== CMakeLists.txt ==================
static const unsigned char temp_binary_data_2[] =
"include(RegexUtils)\r\n"
"test_escape_string_as_regex()\r\n"
"\r\n"
"file(GLOB Eigen_directory_files \"*\")\r\n"
"\r\n"
"escape_string_as_regex(ESCAPED_CMAKE_CURRENT_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}\")\r\n"
"\r\n"
"foreach(f ${Eigen_directory_files})\r\n"
"  if(NOT f MATCHES \"\\\\.txt\" AND NOT f MATCHES \"${ESCAPED_CMAKE_CURRENT_SOURCE_DIR}/[.].+\" AND NOT f MATCHES \"${ESCAPED_CMAKE_CURRENT_SOURCE_DIR}/src\")\r\n"
"    list(APPEND Eigen_directory_files_to_install ${f})\r\n"
"  endif()\r\n"
"endforeach(f ${Eigen_directory_files})\r\n"
"\r\n"
"install(FILES\r\n"
"  ${Eigen_directory_files_to_install}\r\n"
"  DESTINATION ${INCLUDE_INSTALL_DIR}/Eigen COMPONENT Devel\r\n"
"  )\r\n"
"\r\n"
"install(DIRECTORY src DESTINATION ${INCLUDE_INSTALL_DIR}/Eigen COMPONENT Devel FILES_MATCHING PATTERN \"*.h\")\r\n";

const char* CMakeLists_txt = (const char*) temp_binary_data_2;

//================== Core ==================
static const unsigned char temp_binary_data_3[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>\r\n"
"// Copyright (C) 2007-2011 Benoit Jacob <jacob.benoit.1@gmail.com>\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_CORE_H\r\n"
"#define EIGEN_CORE_H\r\n"
"\r\n"
"// first thing Eigen does: stop the compiler from committing suicide\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#if defined(__CUDACC__) && !defined(EIGEN_NO_CUDA)\r\n"
"  #define EIGEN_CUDACC __CUDACC__\r\n"
"#endif\r\n"
"\r\n"
"#if defined(__CUDA_ARCH__) && !defined(EIGEN_NO_CUDA)\r\n"
"  #define EIGEN_CUDA_ARCH __CUDA_ARCH__\r\n"
"#endif\r\n"
"\r\n"
"#if defined(__CUDACC_VER_MAJOR__) && (__CUDACC_VER_MAJOR__ >= 9)\r\n"
"#define EIGEN_CUDACC_VER  ((__CUDACC_VER_MAJOR__ * 10000) + (__CUDACC_VER_MINOR__ * 100))\r\n"
"#elif defined(__CUDACC_VER__)\r\n"
"#define EIGEN_CUDACC_VER __CUDACC_VER__\r\n"
"#else\r\n"
"#define EIGEN_CUDACC_VER 0\r\n"
"#endif\r\n"
"\r\n"
"// Handle NVCC/CUDA/SYCL\r\n"
"#if defined(__CUDACC__) || defined(__SYCL_DEVICE_ONLY__)\r\n"
"  // Do not try asserts on CUDA and SYCL!\r\n"
"  #ifndef EIGEN_NO_DEBUG\r\n"
"  #define EIGEN_NO_DEBUG\r\n"
"  #endif\r\n"
"\r\n"
"  #ifdef EIGEN_INTERNAL_DEBUGGING\r\n"
"  #undef EIGEN_INTERNAL_DEBUGGING\r\n"
"  #endif\r\n"
"\r\n"
"  #ifdef EIGEN_EXCEPTIONS\r\n"
"  #undef EIGEN_EXCEPTIONS\r\n"
"  #endif\r\n"
"\r\n"
"  // All functions callable from CUDA code must be qualified with __device__\r\n"
"  #ifdef __CUDACC__\r\n"
"    // Do not try to vectorize on CUDA and SYCL!\r\n"
"    #ifndef EIGEN_DONT_VECTORIZE\r\n"
"    #define EIGEN_DONT_VECTORIZE\r\n"
"    #endif\r\n"
"\r\n"
"    #define EIGEN_DEVICE_FUNC __host__ __device__\r\n"
"    // We need cuda_runtime.h to ensure that that EIGEN_USING_STD_MATH macro\r\n"
"    // works properly on the device side\r\n"
"    #include <cuda_runtime.h>\r\n"
"  #else\r\n"
"    #define EIGEN_DEVICE_FUNC\r\n"
"  #endif\r\n"
"\r\n"
"#else\r\n"
"  #define EIGEN_DEVICE_FUNC\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"// When compiling CUDA device code with NVCC, pull in math functions from the\r\n"
"// global namespace.  In host mode, and when device doee with clang, use the\r\n"
"// std versions.\r\n"
"#if defined(__CUDA_ARCH__) && defined(__NVCC__)\r\n"
"  #define EIGEN_USING_STD_MATH(FUNC) using ::FUNC;\r\n"
"#else\r\n"
"  #define EIGEN_USING_STD_MATH(FUNC) using std::FUNC;\r\n"
"#endif\r\n"
"\r\n"
"#if (defined(_CPPUNWIND) || defined(__EXCEPTIONS)) && !defined(__CUDA_ARCH__) && !defined(EIGEN_EXCEPTIONS) && !defined(EIGEN_USE_SYCL)\r\n"
"  #define EIGEN_EXCEPTIONS\r\n"
"#endif\r\n"
"\r\n"
"#ifdef EIGEN_EXCEPTIONS\r\n"
"  #include <new>\r\n"
"#endif\r\n"
"\r\n"
"// then include this file where all our macros are defined. It's really important to do it first because\r\n"
"// it's where we do all the alignment settings (platform detection and honoring the user's will if he\r\n"
"// defined e.g. EIGEN_DONT_ALIGN) so it needs to be done before we do anything with vectorization.\r\n"
"#include \"src/Core/util/Macros.h\"\r\n"
"\r\n"
"// Disable the ipa-cp-clone optimization flag with MinGW 6.x or newer (enabled by default with -O3)\r\n"
"// See http://eigen.tuxfamily.org/bz/show_bug.cgi?id=556 for details.\r\n"
"#if EIGEN_COMP_MINGW && EIGEN_GNUC_AT_LEAST(4,6)\r\n"
"  #pragma GCC optimize (\"-fno-ipa-cp-clone\")\r\n"
"#endif\r\n"
"\r\n"
"#include <complex>\r\n"
"\r\n"
"// this include file manages BLAS and MKL related macros\r\n"
"// and inclusion of their respective header files\r\n"
"#include \"src/Core/util/MKL_support.h\"\r\n"
"\r\n"
"// if alignment is disabled, then disable vectorization. Note: EIGEN_MAX_ALIGN_BYTES is the proper check, it takes into\r\n"
"// account both the user's will (EIGEN_MAX_ALIGN_BYTES,EIGEN_DONT_ALIGN) and our own platform checks\r\n"
"#if EIGEN_MAX_ALIGN_BYTES==0\r\n"
"  #ifndef EIGEN_DONT_VECTORIZE\r\n"
"    #define EIGEN_DONT_VECTORIZE\r\n"
"  #endif\r\n"
"#endif\r\n"
"\r\n"
"#if EIGEN_COMP_MSVC\r\n"
"  #include <malloc.h> // for _aligned_malloc -- need it regardless of whether vectorization is enabled\r\n"
"  #if (EIGEN_COMP_MSVC >= 1500) // 2008 or later\r\n"
"    // Remember that usage of defined() in a #define is undefined by the standard.\r\n"
"    // a user reported that in 64-bit mode, MSVC doesn't care to define _M_IX86_FP.\r\n"
"    #if (defined(_M_IX86_FP) && (_M_IX86_FP >= 2)) || EIGEN_ARCH_x86_64\r\n"
"      #define EIGEN_SSE2_ON_MSVC_2008_OR_LATER\r\n"
"    #endif\r\n"
"  #endif\r\n"
"#else\r\n"
"  // Remember that usage of defined() in a #define is undefined by the standard\r\n"
"  #if (defined __SSE2__) && ( (!EIGEN_COMP_GNUC) || EIGEN_COMP_ICC || EIGEN_GNUC_AT_LEAST(4,2) )\r\n"
"    #define EIGEN_SSE2_ON_NON_MSVC_BUT_NOT_OLD_GCC\r\n"
"  #endif\r\n"
"#endif\r\n"
"\r\n"
"#ifndef EIGEN_DONT_VECTORIZE\r\n"
"\r\n"
"  #if defined (EIGEN_SSE2_ON_NON_MSVC_BUT_NOT_OLD_GCC) || defined(EIGEN_SSE2_ON_MSVC_2008_OR_LATER)\r\n"
"\r\n"
"    // Defines symbols for compile-time detection of which instructions are\r\n"
"    // used.\r\n"
"    // EIGEN_VECTORIZE_YY is defined if and only if the instruction set YY is used\r\n"
"    #define EIGEN_VECTORIZE\r\n"
"    #define EIGEN_VECTORIZE_SSE\r\n"
"    #define EIGEN_VECTORIZE_SSE2\r\n"
"\r\n"
"    // Detect sse3/ssse3/sse4:\r\n"
"    // gcc and icc defines __SSE3__, ...\r\n"
"    // there is no way to know about this on msvc. You can define EIGEN_VECTORIZE_SSE* if you\r\n"
"    // want to force the use of those instructions with msvc.\r\n"
"    #ifdef __SSE3__\r\n"
"      #define EIGEN_VECTORIZE_SSE3\r\n"
"    #endif\r\n"
"    #ifdef __SSSE3__\r\n"
"      #define EIGEN_VECTORIZE_SSSE3\r\n"
"    #endif\r\n"
"    #ifdef __SSE4_1__\r\n"
"      #define EIGEN_VECTORIZE_SSE4_1\r\n"
"    #endif\r\n"
"    #ifdef __SSE4_2__\r\n"
"      #define EIGEN_VECTORIZE_SSE4_2\r\n"
"    #endif\r\n"
"    #ifdef __AVX__\r\n"
"      #define EIGEN_VECTORIZE_AVX\r\n"
"      #define EIGEN_VECTORIZE_SSE3\r\n"
"      #define EIGEN_VECTORIZE_SSSE3\r\n"
"      #define EIGEN_VECTORIZE_SSE4_1\r\n"
"      #define EIGEN_VECTORIZE_SSE4_2\r\n"
"    #endif\r\n"
"    #ifdef __AVX2__\r\n"
"      #define EIGEN_VECTORIZE_AVX2\r\n"
"    #endif\r\n"
"    #ifdef __FMA__\r\n"
"      #define EIGEN_VECTORIZE_FMA\r\n"
"    #endif\r\n"
"    #if defined(__AVX512F__) && defined(EIGEN_ENABLE_AVX512)\r\n"
"      #define EIGEN_VECTORIZE_AVX512\r\n"
"      #define EIGEN_VECTORIZE_AVX2\r\n"
"      #define EIGEN_VECTORIZE_AVX\r\n"
"      #define EIGEN_VECTORIZE_FMA\r\n"
"      #ifdef __AVX512DQ__\r\n"
"        #define EIGEN_VECTORIZE_AVX512DQ\r\n"
"      #endif\r\n"
"      #ifdef __AVX512ER__\r\n"
"        #define EIGEN_VECTORIZE_AVX512ER\r\n"
"      #endif\r\n"
"    #endif\r\n"
"\r\n"
"    // include files\r\n"
"\r\n"
"    // This extern \"C\" works around a MINGW-w64 compilation issue\r\n"
"    // https://sourceforge.net/tracker/index.php?func=detail&aid=3018394&group_id=202880&atid=983354\r\n"
"    // In essence, intrin.h is included by windows.h and also declares intrinsics (just as emmintrin.h etc. below do).\r\n"
"    // However, intrin.h uses an extern \"C\" declaration, and g++ thus complains of duplicate declarations\r\n"
"    // with conflicting linkage.  The linkage for intrinsics doesn't matter, but at that stage the compiler doesn't know;\r\n"
"    // so, to avoid compile errors when windows.h is included after Eigen/Core, ensure intrinsics are extern \"C\" here too.\r\n"
"    // notice that since these are C headers, the extern \"C\" is theoretically needed anyways.\r\n"
"    extern \"C\" {\r\n"
"      // In theory we should only include immintrin.h and not the other *mmintrin.h header files directly.\r\n"
"      // Doing so triggers some issues with ICC. However old gcc versions seems to not have this file, thus:\r\n"
"      #if EIGEN_COMP_ICC >= 1110\r\n"
"        #include <immintrin.h>\r\n"
"      #else\r\n"
"        #include <mmintrin.h>\r\n"
"        #include <emmintrin.h>\r\n"
"        #include <xmmintrin.h>\r\n"
"        #ifdef  EIGEN_VECTORIZE_SSE3\r\n"
"        #include <pmmintrin.h>\r\n"
"        #endif\r\n"
"        #ifdef EIGEN_VECTORIZE_SSSE3\r\n"
"        #include <tmmintrin.h>\r\n"
"        #endif\r\n"
"        #ifdef EIGEN_VECTORIZE_SSE4_1\r\n"
"        #include <smmintrin.h>\r\n"
"        #endif\r\n"
"        #ifdef EIGEN_VECTORIZE_SSE4_2\r\n"
"        #include <nmmintrin.h>\r\n"
"        #endif\r\n"
"        #if defined(EIGEN_VECTORIZE_AVX) || defined(EIGEN_VECTORIZE_AVX512)\r\n"
"        #include <immintrin.h>\r\n"
"        #endif\r\n"
"      #endif\r\n"
"    } // end extern \"C\"\r\n"
"  #elif defined __VSX__\r\n"
"    #define EIGEN_VECTORIZE\r\n"
"    #define EIGEN_VECTORIZE_VSX\r\n"
"    #include <altivec.h>\r\n"
"    // We need to #undef all these ugly tokens defined in <altivec.h>\r\n"
"    // => use __vector instead of vector\r\n"
"    #undef bool\r\n"
"    #undef vector\r\n"
"    #undef pixel\r\n"
"  #elif defined __ALTIVEC__\r\n"
"    #define EIGEN_VECTORIZE\r\n"
"    #define EIGEN_VECTORIZE_ALTIVEC\r\n"
"    #include <altivec.h>\r\n"
"    // We need to #undef all these ugly tokens defined in <altivec.h>\r\n"
"    // => use __vector instead of vector\r\n"
"    #undef bool\r\n"
"    #undef vector\r\n"
"    #undef pixel\r\n"
"  #elif (defined  __ARM_NEON) || (defined __ARM_NEON__)\r\n"
"    #define EIGEN_VECTORIZE\r\n"
"    #define EIGEN_VECTORIZE_NEON\r\n"
"    #include <arm_neon.h>\r\n"
"  #elif (defined __s390x__ && defined __VEC__)\r\n"
"    #define EIGEN_VECTORIZE\r\n"
"    #define EIGEN_VECTORIZE_ZVECTOR\r\n"
"    #include <vecintrin.h>\r\n"
"  #endif\r\n"
"#endif\r\n"
"\r\n"
"#if defined(__F16C__) && !defined(EIGEN_COMP_CLANG)\r\n"
"  // We can use the optimized fp16 to float and float to fp16 conversion routines\r\n"
"  #define EIGEN_HAS_FP16_C\r\n"
"#endif\r\n"
"\r\n"
"#if defined __CUDACC__\r\n"
"  #define EIGEN_VECTORIZE_CUDA\r\n"
"  #include <vector_types.h>\r\n"
"  #if EIGEN_CUDACC_VER >= 70500\r\n"
"    #define EIGEN_HAS_CUDA_FP16\r\n"
"  #endif\r\n"
"#endif\r\n"
"\r\n"
"#if defined EIGEN_HAS_CUDA_FP16\r\n"
"  #include <host_defines.h>\r\n"
"  #include <cuda_fp16.h>\r\n"
"#endif\r\n"
"\r\n"
"#if (defined _OPENMP) && (!defined EIGEN_DONT_PARALLELIZE)\r\n"
"  #define EIGEN_HAS_OPENMP\r\n"
"#endif\r\n"
"\r\n"
"#ifdef EIGEN_HAS_OPENMP\r\n"
"#include <omp.h>\r\n"
"#endif\r\n"
"\r\n"
"// MSVC for windows mobile does not have the errno.h file\r\n"
"#if !(EIGEN_COMP_MSVC && EIGEN_OS_WINCE) && !EIGEN_COMP_ARM\r\n"
"#define EIGEN_HAS_ERRNO\r\n"
"#endif\r\n"
"\r\n"
"#ifdef EIGEN_HAS_ERRNO\r\n"
"#include <cerrno>\r\n"
"#endif\r\n"
"#include <cstddef>\r\n"
"#include <cstdlib>\r\n"
"#include <cmath>\r\n"
"#include <cassert>\r\n"
"#include <functional>\r\n"
"#include <iosfwd>\r\n"
"#include <cstring>\r\n"
"#include <string>\r\n"
"#include <limits>\r\n"
"#include <climits> // for CHAR_BIT\r\n"
"// for min/max:\r\n"
"#include <algorithm>\r\n"
"\r\n"
"// for std::is_nothrow_move_assignable\r\n"
"#ifdef EIGEN_INCLUDE_TYPE_TRAITS\r\n"
"#include <type_traits>\r\n"
"#endif\r\n"
"\r\n"
"// for outputting debug info\r\n"
"#ifdef EIGEN_DEBUG_ASSIGN\r\n"
"#include <iostream>\r\n"
"#endif\r\n"
"\r\n"
"// required for __cpuid, needs to be included after cmath\r\n"
"#if EIGEN_COMP_MSVC && EIGEN_ARCH_i386_OR_x86_64 && !EIGEN_OS_WINCE\r\n"
"  #include <intrin.h>\r\n"
"#endif\r\n"
"\r\n"
"/** \\brief Namespace containing all symbols from the %Eigen library. */\r\n"
"namespace Eigen {\r\n"
"\r\n"
"inline static const char *SimdInstructionSetsInUse(void) {\r\n"
"#if defined(EIGEN_VECTORIZE_AVX512)\r\n"
"  return \"AVX512, FMA, AVX2, AVX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2\";\r\n"
"#elif defined(EIGEN_VECTORIZE_AVX)\r\n"
"  return \"AVX SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2\";\r\n"
"#elif defined(EIGEN_VECTORIZE_SSE4_2)\r\n"
"  return \"SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2\";\r\n"
"#elif defined(EIGEN_VECTORIZE_SSE4_1)\r\n"
"  return \"SSE, SSE2, SSE3, SSSE3, SSE4.1\";\r\n"
"#elif defined(EIGEN_VECTORIZE_SSSE3)\r\n"
"  return \"SSE, SSE2, SSE3, SSSE3\";\r\n"
"#elif defined(EIGEN_VECTORIZE_SSE3)\r\n"
"  return \"SSE, SSE2, SSE3\";\r\n"
"#elif defined(EIGEN_VECTORIZE_SSE2)\r\n"
"  return \"SSE, SSE2\";\r\n"
"#elif defined(EIGEN_VECTORIZE_ALTIVEC)\r\n"
"  return \"AltiVec\";\r\n"
"#elif defined(EIGEN_VECTORIZE_VSX)\r\n"
"  return \"VSX\";\r\n"
"#elif defined(EIGEN_VECTORIZE_NEON)\r\n"
"  return \"ARM NEON\";\r\n"
"#elif defined(EIGEN_VECTORIZE_ZVECTOR)\r\n"
"  return \"S390X ZVECTOR\";\r\n"
"#else\r\n"
"  return \"None\";\r\n"
"#endif\r\n"
"}\r\n"
"\r\n"
"} // end namespace Eigen\r\n"
"\r\n"
"#if defined EIGEN2_SUPPORT_STAGE40_FULL_EIGEN3_STRICTNESS || defined EIGEN2_SUPPORT_STAGE30_FULL_EIGEN3_API || defined EIGEN2_SUPPORT_STAGE20_RESOLVE_API_CONFLICTS || defined EIGEN2_SUPPORT_STAGE10_FULL_EIGEN2_API || defined EIGEN2_SUPPORT\r\n"
"// This will generate an error message:\r\n"
"#error Eigen2-support is only available up to version 3.2. Please go to \"http://eigen.tuxfamily.org/index.php?title=Eigen2\" for further information\r\n"
"#endif\r\n"
"\r\n"
"namespace Eigen {\r\n"
"\r\n"
"// we use size_t frequently and we'll never remember to prepend it with std:: everytime just to\r\n"
"// ensure QNX/QCC support\r\n"
"using std::size_t;\r\n"
"// gcc 4.6.0 wants std:: for ptrdiff_t\r\n"
"using std::ptrdiff_t;\r\n"
"\r\n"
"}\r\n"
"\r\n"
"/** \\defgroup Core_Module Core module\r\n"
"  * This is the main module of Eigen providing dense matrix and vector support\r\n"
"  * (both fixed and dynamic size) with all the features corresponding to a BLAS library\r\n"
"  * and much more...\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/Core>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/Core/util/Constants.h\"\r\n"
"#include \"src/Core/util/Meta.h\"\r\n"
"#include \"src/Core/util/ForwardDeclarations.h\"\r\n"
"#include \"src/Core/util/StaticAssert.h\"\r\n"
"#include \"src/Core/util/XprHelper.h\"\r\n"
"#include \"src/Core/util/Memory.h\"\r\n"
"\r\n"
"#include \"src/Core/NumTraits.h\"\r\n"
"#include \"src/Core/MathFunctions.h\"\r\n"
"#include \"src/Core/GenericPacketMath.h\"\r\n"
"#include \"src/Core/MathFunctionsImpl.h\"\r\n"
"#include \"src/Core/arch/Default/ConjHelper.h\"\r\n"
"\r\n"
"#if defined EIGEN_VECTORIZE_AVX512\r\n"
"  #include \"src/Core/arch/SSE/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/AVX/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/AVX512/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/AVX512/MathFunctions.h\"\r\n"
"#elif defined EIGEN_VECTORIZE_AVX\r\n"
"  // Use AVX for floats and doubles, SSE for integers\r\n"
"  #include \"src/Core/arch/SSE/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/SSE/Complex.h\"\r\n"
"  #include \"src/Core/arch/SSE/MathFunctions.h\"\r\n"
"  #include \"src/Core/arch/AVX/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/AVX/MathFunctions.h\"\r\n"
"  #include \"src/Core/arch/AVX/Complex.h\"\r\n"
"  #include \"src/Core/arch/AVX/TypeCasting.h\"\r\n"
"  #include \"src/Core/arch/SSE/TypeCasting.h\"\r\n"
"#elif defined EIGEN_VECTORIZE_SSE\r\n"
"  #include \"src/Core/arch/SSE/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/SSE/MathFunctions.h\"\r\n"
"  #include \"src/Core/arch/SSE/Complex.h\"\r\n"
"  #include \"src/Core/arch/SSE/TypeCasting.h\"\r\n"
"#elif defined(EIGEN_VECTORIZE_ALTIVEC) || defined(EIGEN_VECTORIZE_VSX)\r\n"
"  #include \"src/Core/arch/AltiVec/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/AltiVec/MathFunctions.h\"\r\n"
"  #include \"src/Core/arch/AltiVec/Complex.h\"\r\n"
"#elif defined EIGEN_VECTORIZE_NEON\r\n"
"  #include \"src/Core/arch/NEON/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/NEON/MathFunctions.h\"\r\n"
"  #include \"src/Core/arch/NEON/Complex.h\"\r\n"
"#elif defined EIGEN_VECTORIZE_ZVECTOR\r\n"
"  #include \"src/Core/arch/ZVector/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/ZVector/MathFunctions.h\"\r\n"
"  #include \"src/Core/arch/ZVector/Complex.h\"\r\n"
"#endif\r\n"
"\r\n"
"// Half float support\r\n"
"#include \"src/Core/arch/CUDA/Half.h\"\r\n"
"#include \"src/Core/arch/CUDA/PacketMathHalf.h\"\r\n"
"#include \"src/Core/arch/CUDA/TypeCasting.h\"\r\n"
"\r\n"
"#if defined EIGEN_VECTORIZE_CUDA\r\n"
"  #include \"src/Core/arch/CUDA/PacketMath.h\"\r\n"
"  #include \"src/Core/arch/CUDA/MathFunctions.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/arch/Default/Settings.h\"\r\n"
"\r\n"
"#include \"src/Core/functors/TernaryFunctors.h\"\r\n"
"#include \"src/Core/functors/BinaryFunctors.h\"\r\n"
"#include \"src/Core/functors/UnaryFunctors.h\"\r\n"
"#include \"src/Core/functors/NullaryFunctors.h\"\r\n"
"#include \"src/Core/functors/StlFunctors.h\"\r\n"
"#include \"src/Core/functors/AssignmentFunctors.h\"\r\n"
"\r\n"
"// Specialized functors to enable the processing of complex numbers\r\n"
"// on CUDA devices\r\n"
"#include \"src/Core/arch/CUDA/Complex.h\"\r\n"
"\r\n"
"#include \"src/Core/IO.h\"\r\n"
"#include \"src/Core/DenseCoeffsBase.h\"\r\n"
"#include \"src/Core/DenseBase.h\"\r\n"
"#include \"src/Core/MatrixBase.h\"\r\n"
"#include \"src/Core/EigenBase.h\"\r\n"
"\r\n"
"#include \"src/Core/Product.h\"\r\n"
"#include \"src/Core/CoreEvaluators.h\"\r\n"
"#include \"src/Core/AssignEvaluator.h\"\r\n"
"\r\n"
"#ifndef EIGEN_PARSED_BY_DOXYGEN // work around Doxygen bug triggered by Assign.h r814874\r\n"
"                                // at least confirmed with Doxygen 1.5.5 and 1.5.6\r\n"
"  #include \"src/Core/Assign.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/ArrayBase.h\"\r\n"
"#include \"src/Core/util/BlasUtil.h\"\r\n"
"#include \"src/Core/DenseStorage.h\"\r\n"
"#include \"src/Core/NestByValue.h\"\r\n"
"\r\n"
"// #include \"src/Core/ForceAlignedAccess.h\"\r\n"
"\r\n"
"#include \"src/Core/ReturnByValue.h\"\r\n"
"#include \"src/Core/NoAlias.h\"\r\n"
"#include \"src/Core/PlainObjectBase.h\"\r\n"
"#include \"src/Core/Matrix.h\"\r\n"
"#include \"src/Core/Array.h\"\r\n"
"#include \"src/Core/CwiseTernaryOp.h\"\r\n"
"#include \"src/Core/CwiseBinaryOp.h\"\r\n"
"#include \"src/Core/CwiseUnaryOp.h\"\r\n"
"#include \"src/Core/CwiseNullaryOp.h\"\r\n"
"#include \"src/Core/CwiseUnaryView.h\"\r\n"
"#include \"src/Core/SelfCwiseBinaryOp.h\"\r\n"
"#include \"src/Core/Dot.h\"\r\n"
"#include \"src/Core/StableNorm.h\"\r\n"
"#include \"src/Core/Stride.h\"\r\n"
"#include \"src/Core/MapBase.h\"\r\n"
"#include \"src/Core/Map.h\"\r\n"
"#include \"src/Core/Ref.h\"\r\n"
"#include \"src/Core/Block.h\"\r\n"
"#include \"src/Core/VectorBlock.h\"\r\n"
"#include \"src/Core/Transpose.h\"\r\n"
"#include \"src/Core/DiagonalMatrix.h\"\r\n"
"#include \"src/Core/Diagonal.h\"\r\n"
"#include \"src/Core/DiagonalProduct.h\"\r\n"
"#include \"src/Core/Redux.h\"\r\n"
"#include \"src/Core/Visitor.h\"\r\n"
"#include \"src/Core/Fuzzy.h\"\r\n"
"#include \"src/Core/Swap.h\"\r\n"
"#include \"src/Core/CommaInitializer.h\"\r\n"
"#include \"src/Core/GeneralProduct.h\"\r\n"
"#include \"src/Core/Solve.h\"\r\n"
"#include \"src/Core/Inverse.h\"\r\n"
"#include \"src/Core/SolverBase.h\"\r\n"
"#include \"src/Core/PermutationMatrix.h\"\r\n"
"#include \"src/Core/Transpositions.h\"\r\n"
"#include \"src/Core/TriangularMatrix.h\"\r\n"
"#include \"src/Core/SelfAdjointView.h\"\r\n"
"#include \"src/Core/products/GeneralBlockPanelKernel.h\"\r\n"
"#include \"src/Core/products/Parallelizer.h\"\r\n"
"#include \"src/Core/ProductEvaluators.h\"\r\n"
"#include \"src/Core/products/GeneralMatrixVector.h\"\r\n"
"#include \"src/Core/products/GeneralMatrixMatrix.h\"\r\n"
"#include \"src/Core/SolveTriangular.h\"\r\n"
"#include \"src/Core/products/GeneralMatrixMatrixTriangular.h\"\r\n"
"#include \"src/Core/products/SelfadjointMatrixVector.h\"\r\n"
"#include \"src/Core/products/SelfadjointMatrixMatrix.h\"\r\n"
"#include \"src/Core/products/SelfadjointProduct.h\"\r\n"
"#include \"src/Core/products/SelfadjointRank2Update.h\"\r\n"
"#include \"src/Core/products/TriangularMatrixVector.h\"\r\n"
"#include \"src/Core/products/TriangularMatrixMatrix.h\"\r\n"
"#include \"src/Core/products/TriangularSolverMatrix.h\"\r\n"
"#include \"src/Core/products/TriangularSolverVector.h\"\r\n"
"#include \"src/Core/BandMatrix.h\"\r\n"
"#include \"src/Core/CoreIterators.h\"\r\n"
"#include \"src/Core/ConditionEstimator.h\"\r\n"
"\r\n"
"#include \"src/Core/BooleanRedux.h\"\r\n"
"#include \"src/Core/Select.h\"\r\n"
"#include \"src/Core/VectorwiseOp.h\"\r\n"
"#include \"src/Core/Random.h\"\r\n"
"#include \"src/Core/Replicate.h\"\r\n"
"#include \"src/Core/Reverse.h\"\r\n"
"#include \"src/Core/ArrayWrapper.h\"\r\n"
"\r\n"
"#ifdef EIGEN_USE_BLAS\r\n"
"#include \"src/Core/products/GeneralMatrixMatrix_BLAS.h\"\r\n"
"#include \"src/Core/products/GeneralMatrixVector_BLAS.h\"\r\n"
"#include \"src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h\"\r\n"
"#include \"src/Core/products/SelfadjointMatrixMatrix_BLAS.h\"\r\n"
"#include \"src/Core/products/SelfadjointMatrixVector_BLAS.h\"\r\n"
"#include \"src/Core/products/TriangularMatrixMatrix_BLAS.h\"\r\n"
"#include \"src/Core/products/TriangularMatrixVector_BLAS.h\"\r\n"
"#include \"src/Core/products/TriangularSolverMatrix_BLAS.h\"\r\n"
"#endif // EIGEN_USE_BLAS\r\n"
"\r\n"
"#ifdef EIGEN_USE_MKL_VML\r\n"
"#include \"src/Core/Assign_MKL.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/GlobalFunctions.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_CORE_H\r\n";

const char* Core = (const char*) temp_binary_data_3;

//================== Dense ==================
static const unsigned char temp_binary_data_4[] =
"#include \"Core\"\r\n"
"#include \"LU\"\r\n"
"#include \"Cholesky\"\r\n"
"#include \"QR\"\r\n"
"#include \"SVD\"\r\n"
"#include \"Geometry\"\r\n"
"#include \"Eigenvalues\"\r\n";

const char* Dense = (const char*) temp_binary_data_4;

//================== Eigen ==================
static const unsigned char temp_binary_data_5[] =
"#include \"Dense\"\r\n"
"#include \"Sparse\"\r\n";

const char* Eigen = (const char*) temp_binary_data_5;

//================== Eigenvalues ==================
static const unsigned char temp_binary_data_6[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_EIGENVALUES_MODULE_H\r\n"
"#define EIGEN_EIGENVALUES_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#include \"Cholesky\"\r\n"
"#include \"Jacobi\"\r\n"
"#include \"Householder\"\r\n"
"#include \"LU\"\r\n"
"#include \"Geometry\"\r\n"
"\r\n"
"/** \\defgroup Eigenvalues_Module Eigenvalues module\r\n"
"  *\r\n"
"  *\r\n"
"  *\r\n"
"  * This module mainly provides various eigenvalue solvers.\r\n"
"  * This module also provides some MatrixBase methods, including:\r\n"
"  *  - MatrixBase::eigenvalues(),\r\n"
"  *  - MatrixBase::operatorNorm()\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/Eigenvalues>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/misc/RealSvd2x2.h\"\r\n"
"#include \"src/Eigenvalues/Tridiagonalization.h\"\r\n"
"#include \"src/Eigenvalues/RealSchur.h\"\r\n"
"#include \"src/Eigenvalues/EigenSolver.h\"\r\n"
"#include \"src/Eigenvalues/SelfAdjointEigenSolver.h\"\r\n"
"#include \"src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h\"\r\n"
"#include \"src/Eigenvalues/HessenbergDecomposition.h\"\r\n"
"#include \"src/Eigenvalues/ComplexSchur.h\"\r\n"
"#include \"src/Eigenvalues/ComplexEigenSolver.h\"\r\n"
"#include \"src/Eigenvalues/RealQZ.h\"\r\n"
"#include \"src/Eigenvalues/GeneralizedEigenSolver.h\"\r\n"
"#include \"src/Eigenvalues/MatrixBaseEigenvalues.h\"\r\n"
"#ifdef EIGEN_USE_LAPACKE\r\n"
"#ifdef EIGEN_USE_MKL\r\n"
"#include \"mkl_lapacke.h\"\r\n"
"#else\r\n"
"#include \"src/misc/lapacke.h\"\r\n"
"#endif\r\n"
"#include \"src/Eigenvalues/RealSchur_LAPACKE.h\"\r\n"
"#include \"src/Eigenvalues/ComplexSchur_LAPACKE.h\"\r\n"
"#include \"src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_EIGENVALUES_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* Eigenvalues = (const char*) temp_binary_data_6;

//================== Geometry ==================
static const unsigned char temp_binary_data_7[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_GEOMETRY_MODULE_H\r\n"
"#define EIGEN_GEOMETRY_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#include \"SVD\"\r\n"
"#include \"LU\"\r\n"
"#include <limits>\r\n"
"\r\n"
"/** \\defgroup Geometry_Module Geometry module\r\n"
"  *\r\n"
"  * This module provides support for:\r\n"
"  *  - fixed-size homogeneous transformations\r\n"
"  *  - translation, scaling, 2D and 3D rotations\r\n"
"  *  - \\link Quaternion quaternions \\endlink\r\n"
"  *  - cross products (\\ref MatrixBase::cross, \\ref MatrixBase::cross3)\r\n"
"  *  - orthognal vector generation (\\ref MatrixBase::unitOrthogonal)\r\n"
"  *  - some linear components: \\link ParametrizedLine parametrized-lines \\endlink and \\link Hyperplane hyperplanes \\endlink\r\n"
"  *  - \\link AlignedBox axis aligned bounding boxes \\endlink\r\n"
"  *  - \\link umeyama least-square transformation fitting \\endlink\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/Geometry>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/Geometry/OrthoMethods.h\"\r\n"
"#include \"src/Geometry/EulerAngles.h\"\r\n"
"\r\n"
"#include \"src/Geometry/Homogeneous.h\"\r\n"
"#include \"src/Geometry/RotationBase.h\"\r\n"
"#include \"src/Geometry/Rotation2D.h\"\r\n"
"#include \"src/Geometry/Quaternion.h\"\r\n"
"#include \"src/Geometry/AngleAxis.h\"\r\n"
"#include \"src/Geometry/Transform.h\"\r\n"
"#include \"src/Geometry/Translation.h\"\r\n"
"#include \"src/Geometry/Scaling.h\"\r\n"
"#include \"src/Geometry/Hyperplane.h\"\r\n"
"#include \"src/Geometry/ParametrizedLine.h\"\r\n"
"#include \"src/Geometry/AlignedBox.h\"\r\n"
"#include \"src/Geometry/Umeyama.h\"\r\n"
"\r\n"
"// Use the SSE optimized version whenever possible. At the moment the\r\n"
"// SSE version doesn't compile when AVX is enabled\r\n"
"#if defined EIGEN_VECTORIZE_SSE && !defined EIGEN_VECTORIZE_AVX\r\n"
"#include \"src/Geometry/arch/Geometry_SSE.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_GEOMETRY_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n"
"\r\n";

const char* Geometry = (const char*) temp_binary_data_7;

//================== Householder ==================
static const unsigned char temp_binary_data_8[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_HOUSEHOLDER_MODULE_H\r\n"
"#define EIGEN_HOUSEHOLDER_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \\defgroup Householder_Module Householder module\r\n"
"  * This module provides Householder transformations.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/Householder>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/Householder/Householder.h\"\r\n"
"#include \"src/Householder/HouseholderSequence.h\"\r\n"
"#include \"src/Householder/BlockHouseholder.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_HOUSEHOLDER_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* Householder = (const char*) temp_binary_data_8;

//================== IterativeLinearSolvers ==================
static const unsigned char temp_binary_data_9[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_ITERATIVELINEARSOLVERS_MODULE_H\r\n"
"#define EIGEN_ITERATIVELINEARSOLVERS_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"#include \"OrderingMethods\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \r\n"
"  * \\defgroup IterativeLinearSolvers_Module IterativeLinearSolvers module\r\n"
"  *\r\n"
"  * This module currently provides iterative methods to solve problems of the form \\c A \\c x = \\c b, where \\c A is a squared matrix, usually very large and sparse.\r\n"
"  * Those solvers are accessible via the following classes:\r\n"
"  *  - ConjugateGradient for selfadjoint (hermitian) matrices,\r\n"
"  *  - LeastSquaresConjugateGradient for rectangular least-square problems,\r\n"
"  *  - BiCGSTAB for general square matrices.\r\n"
"  *\r\n"
"  * These iterative solvers are associated with some preconditioners:\r\n"
"  *  - IdentityPreconditioner - not really useful\r\n"
"  *  - DiagonalPreconditioner - also called Jacobi preconditioner, work very well on diagonal dominant matrices.\r\n"
"  *  - IncompleteLUT - incomplete LU factorization with dual thresholding\r\n"
"  *\r\n"
"  * Such problems can also be solved using the direct sparse decomposition modules: SparseCholesky, CholmodSupport, UmfPackSupport, SuperLUSupport.\r\n"
"  *\r\n"
"    \\code\r\n"
"    #include <Eigen/IterativeLinearSolvers>\r\n"
"    \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/IterativeLinearSolvers/SolveWithGuess.h\"\r\n"
"#include \"src/IterativeLinearSolvers/IterativeSolverBase.h\"\r\n"
"#include \"src/IterativeLinearSolvers/BasicPreconditioners.h\"\r\n"
"#include \"src/IterativeLinearSolvers/ConjugateGradient.h\"\r\n"
"#include \"src/IterativeLinearSolvers/LeastSquareConjugateGradient.h\"\r\n"
"#include \"src/IterativeLinearSolvers/BiCGSTAB.h\"\r\n"
"#include \"src/IterativeLinearSolvers/IncompleteLUT.h\"\r\n"
"#include \"src/IterativeLinearSolvers/IncompleteCholesky.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_ITERATIVELINEARSOLVERS_MODULE_H\r\n";

const char* IterativeLinearSolvers = (const char*) temp_binary_data_9;

//================== Jacobi ==================
static const unsigned char temp_binary_data_10[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_JACOBI_MODULE_H\r\n"
"#define EIGEN_JACOBI_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \\defgroup Jacobi_Module Jacobi module\r\n"
"  * This module provides Jacobi and Givens rotations.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/Jacobi>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In addition to listed classes, it defines the two following MatrixBase methods to apply a Jacobi or Givens rotation:\r\n"
"  *  - MatrixBase::applyOnTheLeft()\r\n"
"  *  - MatrixBase::applyOnTheRight().\r\n"
"  */\r\n"
"\r\n"
"#include \"src/Jacobi/Jacobi.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_JACOBI_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n"
"\r\n";

const char* Jacobi = (const char*) temp_binary_data_10;

//================== LU ==================
static const unsigned char temp_binary_data_11[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_LU_MODULE_H\r\n"
"#define EIGEN_LU_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \\defgroup LU_Module LU module\r\n"
"  * This module includes %LU decomposition and related notions such as matrix inversion and determinant.\r\n"
"  * This module defines the following MatrixBase methods:\r\n"
"  *  - MatrixBase::inverse()\r\n"
"  *  - MatrixBase::determinant()\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/LU>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/misc/Kernel.h\"\r\n"
"#include \"src/misc/Image.h\"\r\n"
"#include \"src/LU/FullPivLU.h\"\r\n"
"#include \"src/LU/PartialPivLU.h\"\r\n"
"#ifdef EIGEN_USE_LAPACKE\r\n"
"#ifdef EIGEN_USE_MKL\r\n"
"#include \"mkl_lapacke.h\"\r\n"
"#else\r\n"
"#include \"src/misc/lapacke.h\"\r\n"
"#endif\r\n"
"#include \"src/LU/PartialPivLU_LAPACKE.h\"\r\n"
"#endif\r\n"
"#include \"src/LU/Determinant.h\"\r\n"
"#include \"src/LU/InverseImpl.h\"\r\n"
"\r\n"
"// Use the SSE optimized version whenever possible. At the moment the\r\n"
"// SSE version doesn't compile when AVX is enabled\r\n"
"#if defined EIGEN_VECTORIZE_SSE && !defined EIGEN_VECTORIZE_AVX\r\n"
"  #include \"src/LU/arch/Inverse_SSE.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_LU_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* LU = (const char*) temp_binary_data_11;

//================== MetisSupport ==================
static const unsigned char temp_binary_data_12[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_METISSUPPORT_MODULE_H\r\n"
"#define EIGEN_METISSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"extern \"C\" {\r\n"
"#include <metis.h>\r\n"
"}\r\n"
"\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup MetisSupport_Module MetisSupport module\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/MetisSupport>\r\n"
"  * \\endcode\r\n"
"  * This module defines an interface to the METIS reordering package (http://glaros.dtc.umn.edu/gkhome/views/metis). \r\n"
"  * It can be used just as any other built-in method as explained in \\link OrderingMethods_Module here. \\endlink\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"#include \"src/MetisSupport/MetisSupport.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_METISSUPPORT_MODULE_H\r\n";

const char* MetisSupport = (const char*) temp_binary_data_12;

//================== OrderingMethods ==================
static const unsigned char temp_binary_data_13[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_ORDERINGMETHODS_MODULE_H\r\n"
"#define EIGEN_ORDERINGMETHODS_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \r\n"
"  * \\defgroup OrderingMethods_Module OrderingMethods module\r\n"
"  *\r\n"
"  * This module is currently for internal use only\r\n"
"  * \r\n"
"  * It defines various built-in and external ordering methods for sparse matrices. \r\n"
"  * They are typically used to reduce the number of elements during \r\n"
"  * the sparse matrix decomposition (LLT, LU, QR).\r\n"
"  * Precisely, in a preprocessing step, a permutation matrix P is computed using \r\n"
"  * those ordering methods and applied to the columns of the matrix. \r\n"
"  * Using for instance the sparse Cholesky decomposition, it is expected that \r\n"
"  * the nonzeros elements in LLT(A*P) will be much smaller than that in LLT(A).\r\n"
"  * \r\n"
"  * \r\n"
"  * Usage : \r\n"
"  * \\code\r\n"
"  * #include <Eigen/OrderingMethods>\r\n"
"  * \\endcode\r\n"
"  * \r\n"
"  * A simple usage is as a template parameter in the sparse decomposition classes : \r\n"
"  * \r\n"
"  * \\code \r\n"
"  * SparseLU<MatrixType, COLAMDOrdering<int> > solver;\r\n"
"  * \\endcode \r\n"
"  * \r\n"
"  * \\code \r\n"
"  * SparseQR<MatrixType, COLAMDOrdering<int> > solver;\r\n"
"  * \\endcode\r\n"
"  * \r\n"
"  * It is possible as well to call directly a particular ordering method for your own purpose, \r\n"
"  * \\code \r\n"
"  * AMDOrdering<int> ordering;\r\n"
"  * PermutationMatrix<Dynamic, Dynamic, int> perm;\r\n"
"  * SparseMatrix<double> A; \r\n"
"  * //Fill the matrix ...\r\n"
"  * \r\n"
"  * ordering(A, perm); // Call AMD\r\n"
"  * \\endcode\r\n"
"  * \r\n"
"  * \\note Some of these methods (like AMD or METIS), need the sparsity pattern \r\n"
"  * of the input matrix to be symmetric. When the matrix is structurally unsymmetric, \r\n"
"  * Eigen computes internally the pattern of \\f$A^T*A\\f$ before calling the method.\r\n"
"  * If your matrix is already symmetric (at leat in structure), you can avoid that\r\n"
"  * by calling the method with a SelfAdjointView type.\r\n"
"  * \r\n"
"  * \\code\r\n"
"  *  // Call the ordering on the pattern of the lower triangular matrix A\r\n"
"  * ordering(A.selfadjointView<Lower>(), perm);\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#ifndef EIGEN_MPL2_ONLY\r\n"
"#include \"src/OrderingMethods/Amd.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/OrderingMethods/Ordering.h\"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_ORDERINGMETHODS_MODULE_H\r\n";

const char* OrderingMethods = (const char*) temp_binary_data_13;

//================== PardisoSupport ==================
static const unsigned char temp_binary_data_14[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_PARDISOSUPPORT_MODULE_H\r\n"
"#define EIGEN_PARDISOSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#include <mkl_pardiso.h>\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup PardisoSupport_Module PardisoSupport module\r\n"
"  *\r\n"
"  * This module brings support for the Intel(R) MKL PARDISO direct sparse solvers.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/PardisoSupport>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In order to use this module, the MKL headers must be accessible from the include paths, and your binary must be linked to the MKL library and its dependencies.\r\n"
"  * See this \\ref TopicUsingIntelMKL \"page\" for more information on MKL-Eigen integration.\r\n"
"  * \r\n"
"  */\r\n"
"\r\n"
"#include \"src/PardisoSupport/PardisoSupport.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_PARDISOSUPPORT_MODULE_H\r\n";

const char* PardisoSupport = (const char*) temp_binary_data_14;

//================== PaStiXSupport ==================
static const unsigned char temp_binary_data_15[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_PASTIXSUPPORT_MODULE_H\r\n"
"#define EIGEN_PASTIXSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"extern \"C\" {\r\n"
"#include <pastix_nompi.h>\r\n"
"#include <pastix.h>\r\n"
"}\r\n"
"\r\n"
"#ifdef complex\r\n"
"#undef complex\r\n"
"#endif\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup PaStiXSupport_Module PaStiXSupport module\r\n"
"  * \r\n"
"  * This module provides an interface to the <a href=\"http://pastix.gforge.inria.fr/\">PaSTiX</a> library.\r\n"
"  * PaSTiX is a general \\b supernodal, \\b parallel and \\b opensource sparse solver.\r\n"
"  * It provides the two following main factorization classes:\r\n"
"  * - class PastixLLT : a supernodal, parallel LLt Cholesky factorization.\r\n"
"  * - class PastixLDLT: a supernodal, parallel LDLt Cholesky factorization.\r\n"
"  * - class PastixLU : a supernodal, parallel LU factorization (optimized for a symmetric pattern).\r\n"
"  * \r\n"
"  * \\code\r\n"
"  * #include <Eigen/PaStiXSupport>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In order to use this module, the PaSTiX headers must be accessible from the include paths, and your binary must be linked to the PaSTiX library and its dependencies.\r\n"
"  * The dependencies depend on how PaSTiX has been compiled.\r\n"
"  * For a cmake based project, you can use our FindPaSTiX.cmake module to help you in this task.\r\n"
"  *\r\n"
"  */\r\n"
"\r\n"
"#include \"src/PaStiXSupport/PaStiXSupport.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_PASTIXSUPPORT_MODULE_H\r\n";

const char* PaStiXSupport = (const char*) temp_binary_data_15;

//================== QR ==================
static const unsigned char temp_binary_data_16[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_QR_MODULE_H\r\n"
"#define EIGEN_QR_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#include \"Cholesky\"\r\n"
"#include \"Jacobi\"\r\n"
"#include \"Householder\"\r\n"
"\r\n"
"/** \\defgroup QR_Module QR module\r\n"
"  *\r\n"
"  *\r\n"
"  *\r\n"
"  * This module provides various QR decompositions\r\n"
"  * This module also provides some MatrixBase methods, including:\r\n"
"  *  - MatrixBase::householderQr()\r\n"
"  *  - MatrixBase::colPivHouseholderQr()\r\n"
"  *  - MatrixBase::fullPivHouseholderQr()\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/QR>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/QR/HouseholderQR.h\"\r\n"
"#include \"src/QR/FullPivHouseholderQR.h\"\r\n"
"#include \"src/QR/ColPivHouseholderQR.h\"\r\n"
"#include \"src/QR/CompleteOrthogonalDecomposition.h\"\r\n"
"#ifdef EIGEN_USE_LAPACKE\r\n"
"#ifdef EIGEN_USE_MKL\r\n"
"#include \"mkl_lapacke.h\"\r\n"
"#else\r\n"
"#include \"src/misc/lapacke.h\"\r\n"
"#endif\r\n"
"#include \"src/QR/HouseholderQR_LAPACKE.h\"\r\n"
"#include \"src/QR/ColPivHouseholderQR_LAPACKE.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_QR_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* QR = (const char*) temp_binary_data_16;

//================== QtAlignedMalloc ==================
static const unsigned char temp_binary_data_17[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_QTMALLOC_MODULE_H\r\n"
"#define EIGEN_QTMALLOC_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#if (!EIGEN_MALLOC_ALREADY_ALIGNED)\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"void *qMalloc(std::size_t size)\r\n"
"{\r\n"
"  return Eigen::internal::aligned_malloc(size);\r\n"
"}\r\n"
"\r\n"
"void qFree(void *ptr)\r\n"
"{\r\n"
"  Eigen::internal::aligned_free(ptr);\r\n"
"}\r\n"
"\r\n"
"void *qRealloc(void *ptr, std::size_t size)\r\n"
"{\r\n"
"  void* newPtr = Eigen::internal::aligned_malloc(size);\r\n"
"  std::memcpy(newPtr, ptr, size);\r\n"
"  Eigen::internal::aligned_free(ptr);\r\n"
"  return newPtr;\r\n"
"}\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"#endif // EIGEN_QTMALLOC_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* QtAlignedMalloc = (const char*) temp_binary_data_17;

//================== Sparse ==================
static const unsigned char temp_binary_data_18[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SPARSE_MODULE_H\r\n"
"#define EIGEN_SPARSE_MODULE_H\r\n"
"\r\n"
"/** \\defgroup Sparse_Module Sparse meta-module\r\n"
"  *\r\n"
"  * Meta-module including all related modules:\r\n"
"  * - \\ref SparseCore_Module\r\n"
"  * - \\ref OrderingMethods_Module\r\n"
"  * - \\ref SparseCholesky_Module\r\n"
"  * - \\ref SparseLU_Module\r\n"
"  * - \\ref SparseQR_Module\r\n"
"  * - \\ref IterativeLinearSolvers_Module\r\n"
"  *\r\n"
"    \\code\r\n"
"    #include <Eigen/Sparse>\r\n"
"    \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"#include \"OrderingMethods\"\r\n"
"#ifndef EIGEN_MPL2_ONLY\r\n"
"#include \"SparseCholesky\"\r\n"
"#endif\r\n"
"#include \"SparseLU\"\r\n"
"#include \"SparseQR\"\r\n"
"#include \"IterativeLinearSolvers\"\r\n"
"\r\n"
"#endif // EIGEN_SPARSE_MODULE_H\r\n"
"\r\n";

const char* Sparse = (const char*) temp_binary_data_18;

//================== SparseCholesky ==================
static const unsigned char temp_binary_data_19[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// Copyright (C) 2008-2013 Gael Guennebaud <gael.guennebaud@inria.fr>\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SPARSECHOLESKY_MODULE_H\r\n"
"#define EIGEN_SPARSECHOLESKY_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"#include \"OrderingMethods\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \r\n"
"  * \\defgroup SparseCholesky_Module SparseCholesky module\r\n"
"  *\r\n"
"  * This module currently provides two variants of the direct sparse Cholesky decomposition for selfadjoint (hermitian) matrices.\r\n"
"  * Those decompositions are accessible via the following classes:\r\n"
"  *  - SimplicialLLt,\r\n"
"  *  - SimplicialLDLt\r\n"
"  *\r\n"
"  * Such problems can also be solved using the ConjugateGradient solver from the IterativeLinearSolvers module.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/SparseCholesky>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#ifdef EIGEN_MPL2_ONLY\r\n"
"#error The SparseCholesky module has nothing to offer in MPL2 only mode\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/SparseCholesky/SimplicialCholesky.h\"\r\n"
"\r\n"
"#ifndef EIGEN_MPL2_ONLY\r\n"
"#include \"src/SparseCholesky/SimplicialCholesky_impl.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_SPARSECHOLESKY_MODULE_H\r\n";

const char* SparseCholesky = (const char*) temp_binary_data_19;

//================== SparseCore ==================
static const unsigned char temp_binary_data_20[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SPARSECORE_MODULE_H\r\n"
"#define EIGEN_SPARSECORE_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#include <vector>\r\n"
"#include <map>\r\n"
"#include <cstdlib>\r\n"
"#include <cstring>\r\n"
"#include <algorithm>\r\n"
"\r\n"
"/** \r\n"
"  * \\defgroup SparseCore_Module SparseCore module\r\n"
"  *\r\n"
"  * This module provides a sparse matrix representation, and basic associated matrix manipulations\r\n"
"  * and operations.\r\n"
"  *\r\n"
"  * See the \\ref TutorialSparse \"Sparse tutorial\"\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/SparseCore>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * This module depends on: Core.\r\n"
"  */\r\n"
"\r\n"
"#include \"src/SparseCore/SparseUtil.h\"\r\n"
"#include \"src/SparseCore/SparseMatrixBase.h\"\r\n"
"#include \"src/SparseCore/SparseAssign.h\"\r\n"
"#include \"src/SparseCore/CompressedStorage.h\"\r\n"
"#include \"src/SparseCore/AmbiVector.h\"\r\n"
"#include \"src/SparseCore/SparseCompressedBase.h\"\r\n"
"#include \"src/SparseCore/SparseMatrix.h\"\r\n"
"#include \"src/SparseCore/SparseMap.h\"\r\n"
"#include \"src/SparseCore/MappedSparseMatrix.h\"\r\n"
"#include \"src/SparseCore/SparseVector.h\"\r\n"
"#include \"src/SparseCore/SparseRef.h\"\r\n"
"#include \"src/SparseCore/SparseCwiseUnaryOp.h\"\r\n"
"#include \"src/SparseCore/SparseCwiseBinaryOp.h\"\r\n"
"#include \"src/SparseCore/SparseTranspose.h\"\r\n"
"#include \"src/SparseCore/SparseBlock.h\"\r\n"
"#include \"src/SparseCore/SparseDot.h\"\r\n"
"#include \"src/SparseCore/SparseRedux.h\"\r\n"
"#include \"src/SparseCore/SparseView.h\"\r\n"
"#include \"src/SparseCore/SparseDiagonalProduct.h\"\r\n"
"#include \"src/SparseCore/ConservativeSparseSparseProduct.h\"\r\n"
"#include \"src/SparseCore/SparseSparseProductWithPruning.h\"\r\n"
"#include \"src/SparseCore/SparseProduct.h\"\r\n"
"#include \"src/SparseCore/SparseDenseProduct.h\"\r\n"
"#include \"src/SparseCore/SparseSelfAdjointView.h\"\r\n"
"#include \"src/SparseCore/SparseTriangularView.h\"\r\n"
"#include \"src/SparseCore/TriangularSolver.h\"\r\n"
"#include \"src/SparseCore/SparsePermutation.h\"\r\n"
"#include \"src/SparseCore/SparseFuzzy.h\"\r\n"
"#include \"src/SparseCore/SparseSolverBase.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_SPARSECORE_MODULE_H\r\n"
"\r\n";

const char* SparseCore = (const char*) temp_binary_data_20;

//================== SparseLU ==================
static const unsigned char temp_binary_data_21[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// Copyright (C) 2012 D\xc3\xa9sir\xc3\xa9 Nuentsa-Wakam <desire.nuentsa_wakam@inria.fr>\r\n"
"// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SPARSELU_MODULE_H\r\n"
"#define EIGEN_SPARSELU_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"/** \r\n"
"  * \\defgroup SparseLU_Module SparseLU module\r\n"
"  * This module defines a supernodal factorization of general sparse matrices.\r\n"
"  * The code is fully optimized for supernode-panel updates with specialized kernels.\r\n"
"  * Please, see the documentation of the SparseLU class for more details.\r\n"
"  */\r\n"
"\r\n"
"// Ordering interface\r\n"
"#include \"OrderingMethods\"\r\n"
"\r\n"
"#include \"src/SparseLU/SparseLU_gemm_kernel.h\"\r\n"
"\r\n"
"#include \"src/SparseLU/SparseLU_Structs.h\"\r\n"
"#include \"src/SparseLU/SparseLU_SupernodalMatrix.h\"\r\n"
"#include \"src/SparseLU/SparseLUImpl.h\"\r\n"
"#include \"src/SparseCore/SparseColEtree.h\"\r\n"
"#include \"src/SparseLU/SparseLU_Memory.h\"\r\n"
"#include \"src/SparseLU/SparseLU_heap_relax_snode.h\"\r\n"
"#include \"src/SparseLU/SparseLU_relax_snode.h\"\r\n"
"#include \"src/SparseLU/SparseLU_pivotL.h\"\r\n"
"#include \"src/SparseLU/SparseLU_panel_dfs.h\"\r\n"
"#include \"src/SparseLU/SparseLU_kernel_bmod.h\"\r\n"
"#include \"src/SparseLU/SparseLU_panel_bmod.h\"\r\n"
"#include \"src/SparseLU/SparseLU_column_dfs.h\"\r\n"
"#include \"src/SparseLU/SparseLU_column_bmod.h\"\r\n"
"#include \"src/SparseLU/SparseLU_copy_to_ucol.h\"\r\n"
"#include \"src/SparseLU/SparseLU_pruneL.h\"\r\n"
"#include \"src/SparseLU/SparseLU_Utils.h\"\r\n"
"#include \"src/SparseLU/SparseLU.h\"\r\n"
"\r\n"
"#endif // EIGEN_SPARSELU_MODULE_H\r\n";

const char* SparseLU = (const char*) temp_binary_data_21;

//================== SparseQR ==================
static const unsigned char temp_binary_data_22[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SPARSEQR_MODULE_H\r\n"
"#define EIGEN_SPARSEQR_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"#include \"OrderingMethods\"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \\defgroup SparseQR_Module SparseQR module\r\n"
"  * \\brief Provides QR decomposition for sparse matrices\r\n"
"  * \r\n"
"  * This module provides a simplicial version of the left-looking Sparse QR decomposition. \r\n"
"  * The columns of the input matrix should be reordered to limit the fill-in during the \r\n"
"  * decomposition. Built-in methods (COLAMD, AMD) or external  methods (METIS) can be used to this end.\r\n"
"  * See the \\link OrderingMethods_Module OrderingMethods\\endlink module for the list \r\n"
"  * of built-in and external ordering methods.\r\n"
"  * \r\n"
"  * \\code\r\n"
"  * #include <Eigen/SparseQR>\r\n"
"  * \\endcode\r\n"
"  * \r\n"
"  * \r\n"
"  */\r\n"
"\r\n"
"#include \"OrderingMethods\"\r\n"
"#include \"src/SparseCore/SparseColEtree.h\"\r\n"
"#include \"src/SparseQR/SparseQR.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif\r\n";

const char* SparseQR = (const char*) temp_binary_data_22;

//================== SPQRSupport ==================
static const unsigned char temp_binary_data_23[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SPQRSUPPORT_MODULE_H\r\n"
"#define EIGEN_SPQRSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#include \"SuiteSparseQR.hpp\"\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup SPQRSupport_Module SuiteSparseQR module\r\n"
"  * \r\n"
"  * This module provides an interface to the SPQR library, which is part of the <a href=\"http://www.suitesparse.com\">suitesparse</a> package.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/SPQRSupport>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In order to use this module, the SPQR headers must be accessible from the include paths, and your binary must be linked to the SPQR library and its dependencies (Cholmod, AMD, COLAMD,...).\r\n"
"  * For a cmake based project, you can use our FindSPQR.cmake and FindCholmod.Cmake modules\r\n"
"  *\r\n"
"  */\r\n"
"\r\n"
"#include \"src/CholmodSupport/CholmodSupport.h\"\r\n"
"#include \"src/SPQRSupport/SuiteSparseQRSupport.h\"\r\n"
"\r\n"
"#endif\r\n";

const char* SPQRSupport = (const char*) temp_binary_data_23;

//================== StdDeque ==================
static const unsigned char temp_binary_data_24[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>\r\n"
"// Copyright (C) 2009 Hauke Heibel <hauke.heibel@googlemail.com>\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_STDDEQUE_MODULE_H\r\n"
"#define EIGEN_STDDEQUE_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"#include <deque>\r\n"
"\r\n"
"#if EIGEN_COMP_MSVC && EIGEN_OS_WIN64 && (EIGEN_MAX_STATIC_ALIGN_BYTES<=16) /* MSVC auto aligns up to 16 bytes in 64 bit builds */\r\n"
"\r\n"
"#define EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION(...)\r\n"
"\r\n"
"#else\r\n"
"\r\n"
"#include \"src/StlSupport/StdDeque.h\"\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"#endif // EIGEN_STDDEQUE_MODULE_H\r\n";

const char* StdDeque = (const char*) temp_binary_data_24;

//================== StdList ==================
static const unsigned char temp_binary_data_25[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// Copyright (C) 2009 Hauke Heibel <hauke.heibel@googlemail.com>\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_STDLIST_MODULE_H\r\n"
"#define EIGEN_STDLIST_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"#include <list>\r\n"
"\r\n"
"#if EIGEN_COMP_MSVC && EIGEN_OS_WIN64 && (EIGEN_MAX_STATIC_ALIGN_BYTES<=16) /* MSVC auto aligns up to 16 bytes in 64 bit builds */\r\n"
"\r\n"
"#define EIGEN_DEFINE_STL_LIST_SPECIALIZATION(...)\r\n"
"\r\n"
"#else\r\n"
"\r\n"
"#include \"src/StlSupport/StdList.h\"\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"#endif // EIGEN_STDLIST_MODULE_H\r\n";

const char* StdList = (const char*) temp_binary_data_25;

//================== StdVector ==================
static const unsigned char temp_binary_data_26[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>\r\n"
"// Copyright (C) 2009 Hauke Heibel <hauke.heibel@googlemail.com>\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_STDVECTOR_MODULE_H\r\n"
"#define EIGEN_STDVECTOR_MODULE_H\r\n"
"\r\n"
"#include \"Core\"\r\n"
"#include <vector>\r\n"
"\r\n"
"#if EIGEN_COMP_MSVC && EIGEN_OS_WIN64 && (EIGEN_MAX_STATIC_ALIGN_BYTES<=16) /* MSVC auto aligns up to 16 bytes in 64 bit builds */\r\n"
"\r\n"
"#define EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION(...)\r\n"
"\r\n"
"#else\r\n"
"\r\n"
"#include \"src/StlSupport/StdVector.h\"\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"#endif // EIGEN_STDVECTOR_MODULE_H\r\n";

const char* StdVector = (const char*) temp_binary_data_26;

//================== SuperLUSupport ==================
static const unsigned char temp_binary_data_27[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SUPERLUSUPPORT_MODULE_H\r\n"
"#define EIGEN_SUPERLUSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"#ifdef EMPTY\r\n"
"#define EIGEN_EMPTY_WAS_ALREADY_DEFINED\r\n"
"#endif\r\n"
"\r\n"
"typedef int int_t;\r\n"
"#include <slu_Cnames.h>\r\n"
"#include <supermatrix.h>\r\n"
"#include <slu_util.h>\r\n"
"\r\n"
"// slu_util.h defines a preprocessor token named EMPTY which is really polluting,\r\n"
"// so we remove it in favor of a SUPERLU_EMPTY token.\r\n"
"// If EMPTY was already defined then we don't undef it.\r\n"
"\r\n"
"#if defined(EIGEN_EMPTY_WAS_ALREADY_DEFINED)\r\n"
"# undef EIGEN_EMPTY_WAS_ALREADY_DEFINED\r\n"
"#elif defined(EMPTY)\r\n"
"# undef EMPTY\r\n"
"#endif\r\n"
"\r\n"
"#define SUPERLU_EMPTY (-1)\r\n"
"\r\n"
"namespace Eigen { struct SluMatrix; }\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup SuperLUSupport_Module SuperLUSupport module\r\n"
"  *\r\n"
"  * This module provides an interface to the <a href=\"http://crd-legacy.lbl.gov/~xiaoye/SuperLU/\">SuperLU</a> library.\r\n"
"  * It provides the following factorization class:\r\n"
"  * - class SuperLU: a supernodal sequential LU factorization.\r\n"
"  * - class SuperILU: a supernodal sequential incomplete LU factorization (to be used as a preconditioner for iterative methods).\r\n"
"  *\r\n"
"  * \\warning This wrapper requires at least versions 4.0 of SuperLU. The 3.x versions are not supported.\r\n"
"  *\r\n"
"  * \\warning When including this module, you have to use SUPERLU_EMPTY instead of EMPTY which is no longer defined because it is too polluting.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/SuperLUSupport>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In order to use this module, the superlu headers must be accessible from the include paths, and your binary must be linked to the superlu library and its dependencies.\r\n"
"  * The dependencies depend on how superlu has been compiled.\r\n"
"  * For a cmake based project, you can use our FindSuperLU.cmake module to help you in this task.\r\n"
"  *\r\n"
"  */\r\n"
"\r\n"
"#include \"src/SuperLUSupport/SuperLUSupport.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_SUPERLUSUPPORT_MODULE_H\r\n";

const char* SuperLUSupport = (const char*) temp_binary_data_27;

//================== SVD ==================
static const unsigned char temp_binary_data_28[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_SVD_MODULE_H\r\n"
"#define EIGEN_SVD_MODULE_H\r\n"
"\r\n"
"#include \"QR\"\r\n"
"#include \"Householder\"\r\n"
"#include \"Jacobi\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"/** \\defgroup SVD_Module SVD module\r\n"
"  *\r\n"
"  *\r\n"
"  *\r\n"
"  * This module provides SVD decomposition for matrices (both real and complex).\r\n"
"  * Two decomposition algorithms are provided:\r\n"
"  *  - JacobiSVD implementing two-sided Jacobi iterations is numerically very accurate, fast for small matrices, but very slow for larger ones.\r\n"
"  *  - BDCSVD implementing a recursive divide & conquer strategy on top of an upper-bidiagonalization which remains fast for large problems.\r\n"
"  * These decompositions are accessible via the respective classes and following MatrixBase methods:\r\n"
"  *  - MatrixBase::jacobiSvd()\r\n"
"  *  - MatrixBase::bdcSvd()\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/SVD>\r\n"
"  * \\endcode\r\n"
"  */\r\n"
"\r\n"
"#include \"src/misc/RealSvd2x2.h\"\r\n"
"#include \"src/SVD/UpperBidiagonalization.h\"\r\n"
"#include \"src/SVD/SVDBase.h\"\r\n"
"#include \"src/SVD/JacobiSVD.h\"\r\n"
"#include \"src/SVD/BDCSVD.h\"\r\n"
"#if defined(EIGEN_USE_LAPACKE) && !defined(EIGEN_USE_LAPACKE_STRICT)\r\n"
"#ifdef EIGEN_USE_MKL\r\n"
"#include \"mkl_lapacke.h\"\r\n"
"#else\r\n"
"#include \"src/misc/lapacke.h\"\r\n"
"#endif\r\n"
"#include \"src/SVD/JacobiSVD_LAPACKE.h\"\r\n"
"#endif\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_SVD_MODULE_H\r\n"
"/* vim: set filetype=cpp et sw=2 ts=2 ai: */\r\n";

const char* SVD = (const char*) temp_binary_data_28;

//================== UmfPackSupport ==================
static const unsigned char temp_binary_data_29[] =
"// This file is part of Eigen, a lightweight C++ template library\r\n"
"// for linear algebra.\r\n"
"//\r\n"
"// This Source Code Form is subject to the terms of the Mozilla\r\n"
"// Public License v. 2.0. If a copy of the MPL was not distributed\r\n"
"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n"
"\r\n"
"#ifndef EIGEN_UMFPACKSUPPORT_MODULE_H\r\n"
"#define EIGEN_UMFPACKSUPPORT_MODULE_H\r\n"
"\r\n"
"#include \"SparseCore\"\r\n"
"\r\n"
"#include \"src/Core/util/DisableStupidWarnings.h\"\r\n"
"\r\n"
"extern \"C\" {\r\n"
"#include <umfpack.h>\r\n"
"}\r\n"
"\r\n"
"/** \\ingroup Support_modules\r\n"
"  * \\defgroup UmfPackSupport_Module UmfPackSupport module\r\n"
"  *\r\n"
"  * This module provides an interface to the UmfPack library which is part of the <a href=\"http://www.suitesparse.com\">suitesparse</a> package.\r\n"
"  * It provides the following factorization class:\r\n"
"  * - class UmfPackLU: a multifrontal sequential LU factorization.\r\n"
"  *\r\n"
"  * \\code\r\n"
"  * #include <Eigen/UmfPackSupport>\r\n"
"  * \\endcode\r\n"
"  *\r\n"
"  * In order to use this module, the umfpack headers must be accessible from the include paths, and your binary must be linked to the umfpack library and its dependencies.\r\n"
"  * The dependencies depend on how umfpack has been compiled.\r\n"
"  * For a cmake based project, you can use our FindUmfPack.cmake module to help you in this task.\r\n"
"  *\r\n"
"  */\r\n"
"\r\n"
"#include \"src/UmfPackSupport/UmfPackSupport.h\"\r\n"
"\r\n"
"#include \"src/Core/util/ReenableStupidWarnings.h\"\r\n"
"\r\n"
"#endif // EIGEN_UMFPACKSUPPORT_MODULE_H\r\n";

const char* UmfPackSupport = (const char*) temp_binary_data_29;

//================== gmock-generated-actions.h.pump ==================
static const unsigned char temp_binary_data_30[] =
"$$ -*- mode: c++; -*-\r\n"
"$$ This is a Pump source file (http://go/pump).  Please use Pump to convert\r\n"
"$$ it to callback-actions.h.\r\n"
"$$\r\n"
"$var max_callback_arity = 5\r\n"
"$$}} This meta comment fixes auto-indentation in editors.\r\n"
"#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\r\n"
"#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\r\n"
"\r\n"
"#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\r\n";

const char* gmockgeneratedactions_h_pump = (const char*) temp_binary_data_30;

//================== gmock-generated-internal-utils.h.pump ==================
static const unsigned char temp_binary_data_31[] =
"$$ -*- mode: c++; -*-\r\n"
"$$ This is a Pump source file.  Please use Pump to convert it to\r\n"
"$$ gmock-generated-function-mockers.h.\r\n"
"$$\r\n"
"$var n = 10  $$ The maximum arity we support.\r\n"
"// Copyright 2007, Google Inc.\r\n"
"// All rights reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: wan@google.com (Zhanyong Wan)\r\n"
"\r\n"
"// Google Mock - a framework for writing C++ mock classes.\r\n"
"//\r\n"
"// This file contains template meta-programming utility classes needed\r\n"
"// for implementing Google Mock.\r\n"
"\r\n"
"#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\r\n"
"#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\r\n"
"\r\n"
"#include \"gmock/internal/gmock-port.h\"\r\n"
"\r\n"
"namespace testing {\r\n"
"\r\n"
"template <typename T>\r\n"
"class Matcher;\r\n"
"\r\n"
"namespace internal {\r\n"
"\r\n"
"// An IgnoredValue object can be implicitly constructed from ANY value.\r\n"
"// This is used in implementing the IgnoreResult(a) action.\r\n"
"class IgnoredValue {\r\n"
" public:\r\n"
"  // This constructor template allows any value to be implicitly\r\n"
"  // converted to IgnoredValue.  The object has no data member and\r\n"
"  // doesn't try to remember anything about the argument.  We\r\n"
"  // deliberately omit the 'explicit' keyword in order to allow the\r\n"
"  // conversion to be implicit.\r\n"
"  template <typename T>\r\n"
"  IgnoredValue(const T& /* ignored */) {}  // NOLINT(runtime/explicit)\r\n"
"};\r\n"
"\r\n"
"// MatcherTuple<T>::type is a tuple type where each field is a Matcher\r\n"
"// for the corresponding field in tuple type T.\r\n"
"template <typename Tuple>\r\n"
"struct MatcherTuple;\r\n"
"\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var typename_As = [[$for j, [[typename A$j]]]]\r\n"
"$var As = [[$for j, [[A$j]]]]\r\n"
"$var matcher_As = [[$for j, [[Matcher<A$j>]]]]\r\n"
"template <$typename_As>\r\n"
"struct MatcherTuple< ::testing::tuple<$As> > {\r\n"
"  typedef ::testing::tuple<$matcher_As > type;\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"// Template struct Function<F>, where F must be a function type, contains\r\n"
"// the following typedefs:\r\n"
"//\r\n"
"//   Result:               the function's return type.\r\n"
"//   ArgumentN:            the type of the N-th argument, where N starts with 1.\r\n"
"//   ArgumentTuple:        the tuple type consisting of all parameters of F.\r\n"
"//   ArgumentMatcherTuple: the tuple type consisting of Matchers for all\r\n"
"//                         parameters of F.\r\n"
"//   MakeResultVoid:       the function type obtained by substituting void\r\n"
"//                         for the return type of F.\r\n"
"//   MakeResultIgnoredValue:\r\n"
"//                         the function type obtained by substituting Something\r\n"
"//                         for the return type of F.\r\n"
"template <typename F>\r\n"
"struct Function;\r\n"
"\r\n"
"template <typename R>\r\n"
"struct Function<R()> {\r\n"
"  typedef R Result;\r\n"
"  typedef ::testing::tuple<> ArgumentTuple;\r\n"
"  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\r\n"
"  typedef void MakeResultVoid();\r\n"
"  typedef IgnoredValue MakeResultIgnoredValue();\r\n"
"};\r\n"
"\r\n"
"\r\n"
"$range i 1..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var typename_As = [[$for j [[, typename A$j]]]]\r\n"
"$var As = [[$for j, [[A$j]]]]\r\n"
"$var matcher_As = [[$for j, [[Matcher<A$j>]]]]\r\n"
"$range k 1..i-1\r\n"
"$var prev_As = [[$for k, [[A$k]]]]\r\n"
"template <typename R$typename_As>\r\n"
"struct Function<R($As)>\r\n"
"    : Function<R($prev_As)> {\r\n"
"  typedef A$i Argument$i;\r\n"
"  typedef ::testing::tuple<$As> ArgumentTuple;\r\n"
"  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\r\n"
"  typedef void MakeResultVoid($As);\r\n"
"  typedef IgnoredValue MakeResultIgnoredValue($As);\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"}  // namespace internal\r\n"
"\r\n"
"}  // namespace testing\r\n"
"\r\n"
"#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\r\n";

const char* gmockgeneratedinternalutils_h_pump = (const char*) temp_binary_data_31;

//================== gmock-generated-actions.h.pump ==================
static const unsigned char temp_binary_data_32[] =
"$$ -*- mode: c++; -*-\r\n"
"$$ This is a Pump source file.  Please use Pump to convert it to\r\n"
"$$ gmock-generated-actions.h.\r\n"
"$$\r\n"
"$var n = 10  $$ The maximum arity we support.\r\n"
"$$}} This meta comment fixes auto-indentation in editors.\r\n"
"// Copyright 2007, Google Inc.\r\n"
"// All rights reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: wan@google.com (Zhanyong Wan)\r\n"
"\r\n"
"// Google Mock - a framework for writing C++ mock classes.\r\n"
"//\r\n"
"// This file implements some commonly used variadic actions.\r\n"
"\r\n"
"#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\r\n"
"#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\r\n"
"\r\n"
"#include \"gmock/gmock-actions.h\"\r\n"
"#include \"gmock/internal/gmock-port.h\"\r\n"
"\r\n"
"namespace testing {\r\n"
"namespace internal {\r\n"
"\r\n"
"// InvokeHelper<F> knows how to unpack an N-tuple and invoke an N-ary\r\n"
"// function or method with the unpacked values, where F is a function\r\n"
"// type that takes N arguments.\r\n"
"template <typename Result, typename ArgumentTuple>\r\n"
"class InvokeHelper;\r\n"
"\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var types = [[$for j [[, typename A$j]]]]\r\n"
"$var as = [[$for j, [[A$j]]]]\r\n"
"$var args = [[$if i==0 [[]] $else [[ args]]]]\r\n"
"$var gets = [[$for j, [[get<$(j - 1)>(args)]]]]\r\n"
"template <typename R$types>\r\n"
"class InvokeHelper<R, ::testing::tuple<$as> > {\r\n"
" public:\r\n"
"  template <typename Function>\r\n"
"  static R Invoke(Function function, const ::testing::tuple<$as>&$args) {\r\n"
"           return function($gets);\r\n"
"  }\r\n"
"\r\n"
"  template <class Class, typename MethodPtr>\r\n"
"  static R InvokeMethod(Class* obj_ptr,\r\n"
"                        MethodPtr method_ptr,\r\n"
"                        const ::testing::tuple<$as>&$args) {\r\n"
"           return (obj_ptr->*method_ptr)($gets);\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"// An INTERNAL macro for extracting the type of a tuple field.  It's\r\n"
"// subject to change without notice - DO NOT USE IN USER CODE!\r\n"
"#define GMOCK_FIELD_(Tuple, N) \\\r\n"
"    typename ::testing::tuple_element<N, Tuple>::type\r\n"
"\r\n"
"$range i 1..n\r\n"
"\r\n"
"// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::type is the\r\n"
"// type of an n-ary function whose i-th (1-based) argument type is the\r\n"
"// k{i}-th (0-based) field of ArgumentTuple, which must be a tuple\r\n"
"// type, and whose return type is Result.  For example,\r\n"
"//   SelectArgs<int, ::testing::tuple<bool, char, double, long>, 0, 3>::type\r\n"
"// is int(bool, long).\r\n"
"//\r\n"
"// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::Select(args)\r\n"
"// returns the selected fields (k1, k2, ..., k_n) of args as a tuple.\r\n"
"// For example,\r\n"
"//   SelectArgs<int, tuple<bool, char, double>, 2, 0>::Select(\r\n"
"//       ::testing::make_tuple(true, 'a', 2.5))\r\n"
"// returns tuple (2.5, true).\r\n"
"//\r\n"
"// The numbers in list k1, k2, ..., k_n must be >= 0, where n can be\r\n"
"// in the range [0, $n].  Duplicates are allowed and they don't have\r\n"
"// to be in an ascending or descending order.\r\n"
"\r\n"
"template <typename Result, typename ArgumentTuple, $for i, [[int k$i]]>\r\n"
"class SelectArgs {\r\n"
" public:\r\n"
"  typedef Result type($for i, [[GMOCK_FIELD_(ArgumentTuple, k$i)]]);\r\n"
"  typedef typename Function<type>::ArgumentTuple SelectedArgs;\r\n"
"  static SelectedArgs Select(const ArgumentTuple& args) {\r\n"
"    return SelectedArgs($for i, [[get<k$i>(args)]]);\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 1..n\r\n"
"$range j1 1..i-1\r\n"
"template <typename Result, typename ArgumentTuple$for j1[[, int k$j1]]>\r\n"
"class SelectArgs<Result, ArgumentTuple,\r\n"
"                 $for j, [[$if j <= i-1 [[k$j]] $else [[-1]]]]> {\r\n"
" public:\r\n"
"  typedef Result type($for j1, [[GMOCK_FIELD_(ArgumentTuple, k$j1)]]);\r\n"
"  typedef typename Function<type>::ArgumentTuple SelectedArgs;\r\n"
"  static SelectedArgs Select(const ArgumentTuple& [[]]\r\n"
"$if i == 1 [[/* args */]] $else [[args]]) {\r\n"
"    return SelectedArgs($for j1, [[get<k$j1>(args)]]);\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"#undef GMOCK_FIELD_\r\n"
"\r\n"
"$var ks = [[$for i, [[k$i]]]]\r\n"
"\r\n"
"// Implements the WithArgs action.\r\n"
"template <typename InnerAction, $for i, [[int k$i = -1]]>\r\n"
"class WithArgsAction {\r\n"
" public:\r\n"
"  explicit WithArgsAction(const InnerAction& action) : action_(action) {}\r\n"
"\r\n"
"  template <typename F>\r\n"
"  operator Action<F>() const { return MakeAction(new Impl<F>(action_)); }\r\n"
"\r\n"
" private:\r\n"
"  template <typename F>\r\n"
"  class Impl : public ActionInterface<F> {\r\n"
"   public:\r\n"
"    typedef typename Function<F>::Result Result;\r\n"
"    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\r\n"
"\r\n"
"    explicit Impl(const InnerAction& action) : action_(action) {}\r\n"
"\r\n"
"    virtual Result Perform(const ArgumentTuple& args) {\r\n"
"      return action_.Perform(SelectArgs<Result, ArgumentTuple, $ks>::Select(args));\r\n"
"    }\r\n"
"\r\n"
"   private:\r\n"
"    typedef typename SelectArgs<Result, ArgumentTuple,\r\n"
"        $ks>::type InnerFunctionType;\r\n"
"\r\n"
"    Action<InnerFunctionType> action_;\r\n"
"  };\r\n"
"\r\n"
"  const InnerAction action_;\r\n"
"\r\n"
"  GTEST_DISALLOW_ASSIGN_(WithArgsAction);\r\n"
"};\r\n"
"\r\n"
"// A macro from the ACTION* family (defined later in this file)\r\n"
"// defines an action that can be used in a mock function.  Typically,\r\n"
"// these actions only care about a subset of the arguments of the mock\r\n"
"// function.  For example, if such an action only uses the second\r\n"
"// argument, it can be used in any mock function that takes >= 2\r\n"
"// arguments where the type of the second argument is compatible.\r\n"
"//\r\n"
"// Therefore, the action implementation must be prepared to take more\r\n"
"// arguments than it needs.  The ExcessiveArg type is used to\r\n"
"// represent those excessive arguments.  In order to keep the compiler\r\n"
"// error messages tractable, we define it in the testing namespace\r\n"
"// instead of testing::internal.  However, this is an INTERNAL TYPE\r\n"
"// and subject to change without notice, so a user MUST NOT USE THIS\r\n"
"// TYPE DIRECTLY.\r\n"
"struct ExcessiveArg {};\r\n"
"\r\n"
"// A helper class needed for implementing the ACTION* macros.\r\n"
"template <typename Result, class Impl>\r\n"
"class ActionHelper {\r\n"
" public:\r\n"
"$range i 0..n\r\n"
"$for i\r\n"
"\r\n"
"[[\r\n"
"$var template = [[$if i==0 [[]] $else [[\r\n"
"$range j 0..i-1\r\n"
"  template <$for j, [[typename A$j]]>\r\n"
"]]]]\r\n"
"$range j 0..i-1\r\n"
"$var As = [[$for j, [[A$j]]]]\r\n"
"$var as = [[$for j, [[get<$j>(args)]]]]\r\n"
"$range k 1..n-i\r\n"
"$var eas = [[$for k, [[ExcessiveArg()]]]]\r\n"
"$var arg_list = [[$if (i==0) | (i==n) [[$as$eas]] $else [[$as, $eas]]]]\r\n"
"$template\r\n"
"  static Result Perform(Impl* impl, const ::testing::tuple<$As>& args) {\r\n"
"    return impl->template gmock_PerformImpl<$As>(args, $arg_list);\r\n"
"  }\r\n"
"\r\n"
"]]\r\n"
"};\r\n"
"\r\n"
"}  // namespace internal\r\n"
"\r\n"
"// Various overloads for Invoke().\r\n"
"\r\n"
"// WithArgs<N1, N2, ..., Nk>(an_action) creates an action that passes\r\n"
"// the selected arguments of the mock function to an_action and\r\n"
"// performs it.  It serves as an adaptor between actions with\r\n"
"// different argument lists.  C++ doesn't support default arguments for\r\n"
"// function templates, so we have to overload it.\r\n"
"\r\n"
"$range i 1..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"template <$for j [[int k$j, ]]typename InnerAction>\r\n"
"inline internal::WithArgsAction<InnerAction$for j [[, k$j]]>\r\n"
"WithArgs(const InnerAction& action) {\r\n"
"  return internal::WithArgsAction<InnerAction$for j [[, k$j]]>(action);\r\n"
"}\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"// Creates an action that does actions a1, a2, ..., sequentially in\r\n"
"// each invocation.\r\n"
"$range i 2..n\r\n"
"$for i [[\r\n"
"$range j 2..i\r\n"
"$var types = [[$for j, [[typename Action$j]]]]\r\n"
"$var Aas = [[$for j [[, Action$j a$j]]]]\r\n"
"\r\n"
"template <typename Action1, $types>\r\n"
"$range k 1..i-1\r\n"
"\r\n"
"inline $for k [[internal::DoBothAction<Action$k, ]]Action$i$for k  [[>]]\r\n"
"\r\n"
"DoAll(Action1 a1$Aas) {\r\n"
"$if i==2 [[\r\n"
"\r\n"
"  return internal::DoBothAction<Action1, Action2>(a1, a2);\r\n"
"]] $else [[\r\n"
"$range j2 2..i\r\n"
"\r\n"
"  return DoAll(a1, DoAll($for j2, [[a$j2]]));\r\n"
"]]\r\n"
"\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"}  // namespace testing\r\n"
"\r\n"
"// The ACTION* family of macros can be used in a namespace scope to\r\n"
"// define custom actions easily.  The syntax:\r\n"
"//\r\n"
"//   ACTION(name) { statements; }\r\n"
"//\r\n"
"// will define an action with the given name that executes the\r\n"
"// statements.  The value returned by the statements will be used as\r\n"
"// the return value of the action.  Inside the statements, you can\r\n"
"// refer to the K-th (0-based) argument of the mock function by\r\n"
"// 'argK', and refer to its type by 'argK_type'.  For example:\r\n"
"//\r\n"
"//   ACTION(IncrementArg1) {\r\n"
"//     arg1_type temp = arg1;\r\n"
"//     return ++(*temp);\r\n"
"//   }\r\n"
"//\r\n"
"// allows you to write\r\n"
"//\r\n"
"//   ...WillOnce(IncrementArg1());\r\n"
"//\r\n"
"// You can also refer to the entire argument tuple and its type by\r\n"
"// 'args' and 'args_type', and refer to the mock function type and its\r\n"
"// return type by 'function_type' and 'return_type'.\r\n"
"//\r\n"
"// Note that you don't need to specify the types of the mock function\r\n"
"// arguments.  However rest assured that your code is still type-safe:\r\n"
"// you'll get a compiler error if *arg1 doesn't support the ++\r\n"
"// operator, or if the type of ++(*arg1) isn't compatible with the\r\n"
"// mock function's return type, for example.\r\n"
"//\r\n"
"// Sometimes you'll want to parameterize the action.   For that you can use\r\n"
"// another macro:\r\n"
"//\r\n"
"//   ACTION_P(name, param_name) { statements; }\r\n"
"//\r\n"
"// For example:\r\n"
"//\r\n"
"//   ACTION_P(Add, n) { return arg0 + n; }\r\n"
"//\r\n"
"// will allow you to write:\r\n"
"//\r\n"
"//   ...WillOnce(Add(5));\r\n"
"//\r\n"
"// Note that you don't need to provide the type of the parameter\r\n"
"// either.  If you need to reference the type of a parameter named\r\n"
"// 'foo', you can write 'foo_type'.  For example, in the body of\r\n"
"// ACTION_P(Add, n) above, you can write 'n_type' to refer to the type\r\n"
"// of 'n'.\r\n"
"//\r\n"
"// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P$n to support\r\n"
"// multi-parameter actions.\r\n"
"//\r\n"
"// For the purpose of typing, you can view\r\n"
"//\r\n"
"//   ACTION_Pk(Foo, p1, ..., pk) { ... }\r\n"
"//\r\n"
"// as shorthand for\r\n"
"//\r\n"
"//   template <typename p1_type, ..., typename pk_type>\r\n"
"//   FooActionPk<p1_type, ..., pk_type> Foo(p1_type p1, ..., pk_type pk) { ... }\r\n"
"//\r\n"
"// In particular, you can provide the template type arguments\r\n"
"// explicitly when invoking Foo(), as in Foo<long, bool>(5, false);\r\n"
"// although usually you can rely on the compiler to infer the types\r\n"
"// for you automatically.  You can assign the result of expression\r\n"
"// Foo(p1, ..., pk) to a variable of type FooActionPk<p1_type, ...,\r\n"
"// pk_type>.  This can be useful when composing actions.\r\n"
"//\r\n"
"// You can also overload actions with different numbers of parameters:\r\n"
"//\r\n"
"//   ACTION_P(Plus, a) { ... }\r\n"
"//   ACTION_P2(Plus, a, b) { ... }\r\n"
"//\r\n"
"// While it's tempting to always use the ACTION* macros when defining\r\n"
"// a new action, you should also consider implementing ActionInterface\r\n"
"// or using MakePolymorphicAction() instead, especially if you need to\r\n"
"// use the action a lot.  While these approaches require more work,\r\n"
"// they give you more control on the types of the mock function\r\n"
"// arguments and the action parameters, which in general leads to\r\n"
"// better compiler error messages that pay off in the long run.  They\r\n"
"// also allow overloading actions based on parameter types (as opposed\r\n"
"// to just based on the number of parameters).\r\n"
"//\r\n"
"// CAVEAT:\r\n"
"//\r\n"
"// ACTION*() can only be used in a namespace scope.  The reason is\r\n"
"// that C++ doesn't yet allow function-local types to be used to\r\n"
"// instantiate templates.  The up-coming C++0x standard will fix this.\r\n"
"// Once that's done, we'll consider supporting using ACTION*() inside\r\n"
"// a function.\r\n"
"//\r\n"
"// MORE INFORMATION:\r\n"
"//\r\n"
"// To learn more about using these macros, please search for 'ACTION'\r\n"
"// on http://code.google.com/p/googlemock/wiki/CookBook.\r\n"
"\r\n"
"$range i 0..n\r\n"
"$range k 0..n-1\r\n"
"\r\n"
"// An internal macro needed for implementing ACTION*().\r\n"
"#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\\\r\n"
"    const args_type& args GTEST_ATTRIBUTE_UNUSED_\r\n"
"$for k [[, \\\r\n"
"    arg$k[[]]_type arg$k GTEST_ATTRIBUTE_UNUSED_]]\r\n"
"\r\n"
"\r\n"
"// Sometimes you want to give an action explicit template parameters\r\n"
"// that cannot be inferred from its value parameters.  ACTION() and\r\n"
"// ACTION_P*() don't support that.  ACTION_TEMPLATE() remedies that\r\n"
"// and can be viewed as an extension to ACTION() and ACTION_P*().\r\n"
"//\r\n"
"// The syntax:\r\n"
"//\r\n"
"//   ACTION_TEMPLATE(ActionName,\r\n"
"//                   HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),\r\n"
"//                   AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }\r\n"
"//\r\n"
"// defines an action template that takes m explicit template\r\n"
"// parameters and n value parameters.  name_i is the name of the i-th\r\n"
"// template parameter, and kind_i specifies whether it's a typename,\r\n"
"// an integral constant, or a template.  p_i is the name of the i-th\r\n"
"// value parameter.\r\n"
"//\r\n"
"// Example:\r\n"
"//\r\n"
"//   // DuplicateArg<k, T>(output) converts the k-th argument of the mock\r\n"
"//   // function to type T and copies it to *output.\r\n"
"//   ACTION_TEMPLATE(DuplicateArg,\r\n"
"//                   HAS_2_TEMPLATE_PARAMS(int, k, typename, T),\r\n"
"//                   AND_1_VALUE_PARAMS(output)) {\r\n"
"//     *output = T(::testing::get<k>(args));\r\n"
"//   }\r\n"
"//   ...\r\n"
"//     int n;\r\n"
"//     EXPECT_CALL(mock, Foo(_, _))\r\n"
"//         .WillOnce(DuplicateArg<1, unsigned char>(&n));\r\n"
"//\r\n"
"// To create an instance of an action template, write:\r\n"
"//\r\n"
"//   ActionName<t1, ..., t_m>(v1, ..., v_n)\r\n"
"//\r\n"
"// where the ts are the template arguments and the vs are the value\r\n"
"// arguments.  The value argument types are inferred by the compiler.\r\n"
"// If you want to explicitly specify the value argument types, you can\r\n"
"// provide additional template arguments:\r\n"
"//\r\n"
"//   ActionName<t1, ..., t_m, u1, ..., u_k>(v1, ..., v_n)\r\n"
"//\r\n"
"// where u_i is the desired type of v_i.\r\n"
"//\r\n"
"// ACTION_TEMPLATE and ACTION/ACTION_P* can be overloaded on the\r\n"
"// number of value parameters, but not on the number of template\r\n"
"// parameters.  Without the restriction, the meaning of the following\r\n"
"// is unclear:\r\n"
"//\r\n"
"//   OverloadedAction<int, bool>(x);\r\n"
"//\r\n"
"// Are we using a single-template-parameter action where 'bool' refers\r\n"
"// to the type of x, or are we using a two-template-parameter action\r\n"
"// where the compiler is asked to infer the type of x?\r\n"
"//\r\n"
"// Implementation notes:\r\n"
"//\r\n"
"// GMOCK_INTERNAL_*_HAS_m_TEMPLATE_PARAMS and\r\n"
"// GMOCK_INTERNAL_*_AND_n_VALUE_PARAMS are internal macros for\r\n"
"// implementing ACTION_TEMPLATE.  The main trick we use is to create\r\n"
"// new macro invocations when expanding a macro.  For example, we have\r\n"
"//\r\n"
"//   #define ACTION_TEMPLATE(name, template_params, value_params)\r\n"
"//       ... GMOCK_INTERNAL_DECL_##template_params ...\r\n"
"//\r\n"
"// which causes ACTION_TEMPLATE(..., HAS_1_TEMPLATE_PARAMS(typename, T), ...)\r\n"
"// to expand to\r\n"
"//\r\n"
"//       ... GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(typename, T) ...\r\n"
"//\r\n"
"// Since GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS is a macro, the\r\n"
"// preprocessor will continue to expand it to\r\n"
"//\r\n"
"//       ... typename T ...\r\n"
"//\r\n"
"// This technique conforms to the C++ standard and is portable.  It\r\n"
"// allows us to implement action templates using O(N) code, where N is\r\n"
"// the maximum number of template/value parameters supported.  Without\r\n"
"// using it, we'd have to devote O(N^2) amount of code to implement all\r\n"
"// combinations of m and n.\r\n"
"\r\n"
"// Declares the template parameters.\r\n"
"\r\n"
"$range j 1..n\r\n"
"$for j [[\r\n"
"$range m 0..j-1\r\n"
"#define GMOCK_INTERNAL_DECL_HAS_$j[[]]\r\n"
"_TEMPLATE_PARAMS($for m, [[kind$m, name$m]]) $for m, [[kind$m name$m]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Lists the template parameters.\r\n"
"\r\n"
"$for j [[\r\n"
"$range m 0..j-1\r\n"
"#define GMOCK_INTERNAL_LIST_HAS_$j[[]]\r\n"
"_TEMPLATE_PARAMS($for m, [[kind$m, name$m]]) $for m, [[name$m]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Declares the types of value parameters.\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_DECL_TYPE_AND_$i[[]]\r\n"
"_VALUE_PARAMS($for j, [[p$j]]) $for j [[, typename p$j##_type]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Initializes the value parameters.\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_INIT_AND_$i[[]]_VALUE_PARAMS($for j, [[p$j]])\\\r\n"
"    ($for j, [[p$j##_type gmock_p$j]])$if i>0 [[ : ]]$for j, [[p$j(gmock_p$j)]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Declares the fields for storing the value parameters.\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_DEFN_AND_$i[[]]\r\n"
"_VALUE_PARAMS($for j, [[p$j]]) $for j [[p$j##_type p$j; ]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Lists the value parameters.\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_LIST_AND_$i[[]]\r\n"
"_VALUE_PARAMS($for j, [[p$j]]) $for j, [[p$j]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Lists the value parameter types.\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_LIST_TYPE_AND_$i[[]]\r\n"
"_VALUE_PARAMS($for j, [[p$j]]) $for j [[, p$j##_type]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Declares the value parameters.\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_DECL_AND_$i[[]]_VALUE_PARAMS($for j, [[p$j]]) [[]]\r\n"
"$for j, [[p$j##_type p$j]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// The suffix of the class template implementing the action template.\r\n"
"$for i [[\r\n"
"\r\n"
"\r\n"
"$range j 0..i-1\r\n"
"#define GMOCK_INTERNAL_COUNT_AND_$i[[]]_VALUE_PARAMS($for j, [[p$j]]) [[]]\r\n"
"$if i==1 [[P]] $elif i>=2 [[P$i]]\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"// The name of the class template implementing the action template.\r\n"
"#define GMOCK_ACTION_CLASS_(name, value_params)\\\r\n"
"    GTEST_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)\r\n"
"\r\n"
"$range k 0..n-1\r\n"
"\r\n"
"#define ACTION_TEMPLATE(name, template_params, value_params)\\\r\n"
"  template <GMOCK_INTERNAL_DECL_##template_params\\\r\n"
"            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\r\n"
"  class GMOCK_ACTION_CLASS_(name, value_params) {\\\r\n"
"   public:\\\r\n"
"    explicit GMOCK_ACTION_CLASS_(name, value_params)\\\r\n"
"        GMOCK_INTERNAL_INIT_##value_params {}\\\r\n"
"    template <typename F>\\\r\n"
"    class gmock_Impl : public ::testing::ActionInterface<F> {\\\r\n"
"     public:\\\r\n"
"      typedef F function_type;\\\r\n"
"      typedef typename ::testing::internal::Function<F>::Result return_type;\\\r\n"
"      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\r\n"
"          args_type;\\\r\n"
"      explicit gmock_Impl GMOCK_INTERNAL_INIT_##value_params {}\\\r\n"
"      virtual return_type Perform(const args_type& args) {\\\r\n"
"        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\r\n"
"            Perform(this, args);\\\r\n"
"      }\\\r\n"
"      template <$for k, [[typename arg$k[[]]_type]]>\\\r\n"
"      return_type gmock_PerformImpl(const args_type& args[[]]\r\n"
"$for k [[, arg$k[[]]_type arg$k]]) const;\\\r\n"
"      GMOCK_INTERNAL_DEFN_##value_params\\\r\n"
"     private:\\\r\n"
"      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\r\n"
"    };\\\r\n"
"    template <typename F> operator ::testing::Action<F>() const {\\\r\n"
"      return ::testing::Action<F>(\\\r\n"
"          new gmock_Impl<F>(GMOCK_INTERNAL_LIST_##value_params));\\\r\n"
"    }\\\r\n"
"    GMOCK_INTERNAL_DEFN_##value_params\\\r\n"
"   private:\\\r\n"
"    GTEST_DISALLOW_ASSIGN_(GMOCK_ACTION_CLASS_(name, value_params));\\\r\n"
"  };\\\r\n"
"  template <GMOCK_INTERNAL_DECL_##template_params\\\r\n"
"            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\r\n"
"  inline GMOCK_ACTION_CLASS_(name, value_params)<\\\r\n"
"      GMOCK_INTERNAL_LIST_##template_params\\\r\n"
"      GMOCK_INTERNAL_LIST_TYPE_##value_params> name(\\\r\n"
"          GMOCK_INTERNAL_DECL_##value_params) {\\\r\n"
"    return GMOCK_ACTION_CLASS_(name, value_params)<\\\r\n"
"        GMOCK_INTERNAL_LIST_##template_params\\\r\n"
"        GMOCK_INTERNAL_LIST_TYPE_##value_params>(\\\r\n"
"            GMOCK_INTERNAL_LIST_##value_params);\\\r\n"
"  }\\\r\n"
"  template <GMOCK_INTERNAL_DECL_##template_params\\\r\n"
"            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\r\n"
"  template <typename F>\\\r\n"
"  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\r\n"
"      typename arg3_type, typename arg4_type, typename arg5_type, \\\r\n"
"      typename arg6_type, typename arg7_type, typename arg8_type, \\\r\n"
"      typename arg9_type>\\\r\n"
"  typename ::testing::internal::Function<F>::Result\\\r\n"
"      GMOCK_ACTION_CLASS_(name, value_params)<\\\r\n"
"          GMOCK_INTERNAL_LIST_##template_params\\\r\n"
"          GMOCK_INTERNAL_LIST_TYPE_##value_params>::gmock_Impl<F>::\\\r\n"
"              gmock_PerformImpl(\\\r\n"
"          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\r\n"
"\r\n"
"$for i\r\n"
"\r\n"
"[[\r\n"
"$var template = [[$if i==0 [[]] $else [[\r\n"
"$range j 0..i-1\r\n"
"\r\n"
"  template <$for j, [[typename p$j##_type]]>\\\r\n"
"]]]]\r\n"
"$var class_name = [[name##Action[[$if i==0 [[]] $elif i==1 [[P]]\r\n"
"                                                $else [[P$i]]]]]]\r\n"
"$range j 0..i-1\r\n"
"$var ctor_param_list = [[$for j, [[p$j##_type gmock_p$j]]]]\r\n"
"$var param_types_and_names = [[$for j, [[p$j##_type p$j]]]]\r\n"
"$var inits = [[$if i==0 [[]] $else [[ : $for j, [[p$j(gmock_p$j)]]]]]]\r\n"
"$var param_field_decls = [[$for j\r\n"
"[[\r\n"
"\r\n"
"      p$j##_type p$j;\\\r\n"
"]]]]\r\n"
"$var param_field_decls2 = [[$for j\r\n"
"[[\r\n"
"\r\n"
"    p$j##_type p$j;\\\r\n"
"]]]]\r\n"
"$var params = [[$for j, [[p$j]]]]\r\n"
"$var param_types = [[$if i==0 [[]] $else [[<$for j, [[p$j##_type]]>]]]]\r\n"
"$var typename_arg_types = [[$for k, [[typename arg$k[[]]_type]]]]\r\n"
"$var arg_types_and_names = [[$for k, [[arg$k[[]]_type arg$k]]]]\r\n"
"$var macro_name = [[$if i==0 [[ACTION]] $elif i==1 [[ACTION_P]]\r\n"
"                                        $else [[ACTION_P$i]]]]\r\n"
"\r\n"
"#define $macro_name(name$for j [[, p$j]])\\$template\r\n"
"  class $class_name {\\\r\n"
"   public:\\\r\n"
"    [[$if i==1 [[explicit ]]]]$class_name($ctor_param_list)$inits {}\\\r\n"
"    template <typename F>\\\r\n"
"    class gmock_Impl : public ::testing::ActionInterface<F> {\\\r\n"
"     public:\\\r\n"
"      typedef F function_type;\\\r\n"
"      typedef typename ::testing::internal::Function<F>::Result return_type;\\\r\n"
"      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\r\n"
"          args_type;\\\r\n"
"      [[$if i==1 [[explicit ]]]]gmock_Impl($ctor_param_list)$inits {}\\\r\n"
"      virtual return_type Perform(const args_type& args) {\\\r\n"
"        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\r\n"
"            Perform(this, args);\\\r\n"
"      }\\\r\n"
"      template <$typename_arg_types>\\\r\n"
"      return_type gmock_PerformImpl(const args_type& args, [[]]\r\n"
"$arg_types_and_names) const;\\$param_field_decls\r\n"
"     private:\\\r\n"
"      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\r\n"
"    };\\\r\n"
"    template <typename F> operator ::testing::Action<F>() const {\\\r\n"
"      return ::testing::Action<F>(new gmock_Impl<F>($params));\\\r\n"
"    }\\$param_field_decls2\r\n"
"   private:\\\r\n"
"    GTEST_DISALLOW_ASSIGN_($class_name);\\\r\n"
"  };\\$template\r\n"
"  inline $class_name$param_types name($param_types_and_names) {\\\r\n"
"    return $class_name$param_types($params);\\\r\n"
"  }\\$template\r\n"
"  template <typename F>\\\r\n"
"  template <$typename_arg_types>\\\r\n"
"  typename ::testing::internal::Function<F>::Result\\\r\n"
"      $class_name$param_types::gmock_Impl<F>::gmock_PerformImpl(\\\r\n"
"          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\r\n"
"]]\r\n"
"$$ }  // This meta comment fixes auto-indentation in Emacs.  It won't\r\n"
"$$    // show up in the generated code.\r\n"
"\r\n"
"\r\n"
"namespace testing {\r\n"
"\r\n"
"\r\n"
"// The ACTION*() macros trigger warning C4100 (unreferenced formal\r\n"
"// parameter) in MSVC with -W4.  Unfortunately they cannot be fixed in\r\n"
"// the macro definition, as the warnings are generated when the macro\r\n"
"// is expanded and macro expansion cannot contain #pragma.  Therefore\r\n"
"// we suppress them here.\r\n"
"#ifdef _MSC_VER\r\n"
"# pragma warning(push)\r\n"
"# pragma warning(disable:4100)\r\n"
"#endif\r\n"
"\r\n"
"// Various overloads for InvokeArgument<N>().\r\n"
"//\r\n"
"// The InvokeArgument<N>(a1, a2, ..., a_k) action invokes the N-th\r\n"
"// (0-based) argument, which must be a k-ary callable, of the mock\r\n"
"// function, with arguments a1, a2, ..., a_k.\r\n"
"//\r\n"
"// Notes:\r\n"
"//\r\n"
"//   1. The arguments are passed by value by default.  If you need to\r\n"
"//   pass an argument by reference, wrap it inside ByRef().  For\r\n"
"//   example,\r\n"
"//\r\n"
"//     InvokeArgument<1>(5, string(\"Hello\"), ByRef(foo))\r\n"
"//\r\n"
"//   passes 5 and string(\"Hello\") by value, and passes foo by\r\n"
"//   reference.\r\n"
"//\r\n"
"//   2. If the callable takes an argument by reference but ByRef() is\r\n"
"//   not used, it will receive the reference to a copy of the value,\r\n"
"//   instead of the original value.  For example, when the 0-th\r\n"
"//   argument of the mock function takes a const string&, the action\r\n"
"//\r\n"
"//     InvokeArgument<0>(string(\"Hello\"))\r\n"
"//\r\n"
"//   makes a copy of the temporary string(\"Hello\") object and passes a\r\n"
"//   reference of the copy, instead of the original temporary object,\r\n"
"//   to the callable.  This makes it easy for a user to define an\r\n"
"//   InvokeArgument action from temporary values and have it performed\r\n"
"//   later.\r\n"
"\r\n"
"namespace internal {\r\n"
"namespace invoke_argument {\r\n"
"\r\n"
"// Appears in InvokeArgumentAdl's argument list to help avoid\r\n"
"// accidental calls to user functions of the same name.\r\n"
"struct AdlTag {};\r\n"
"\r\n"
"// InvokeArgumentAdl - a helper for InvokeArgument.\r\n"
"// The basic overloads are provided here for generic functors.\r\n"
"// Overloads for other custom-callables are provided in the\r\n"
"// internal/custom/callback-actions.h header.\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i\r\n"
"[[\r\n"
"$range j 1..i\r\n"
"\r\n"
"template <typename R, typename F[[$for j [[, typename A$j]]]]>\r\n"
"R InvokeArgumentAdl(AdlTag, F f[[$for j [[, A$j a$j]]]]) {\r\n"
"  return f([[$for j, [[a$j]]]]);\r\n"
"}\r\n"
"]]\r\n"
"\r\n"
"}  // namespace invoke_argument\r\n"
"}  // namespace internal\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"\r\n"
"ACTION_TEMPLATE(InvokeArgument,\r\n"
"                HAS_1_TEMPLATE_PARAMS(int, k),\r\n"
"                AND_$i[[]]_VALUE_PARAMS($for j, [[p$j]])) {\r\n"
"  using internal::invoke_argument::InvokeArgumentAdl;\r\n"
"  return InvokeArgumentAdl<return_type>(\r\n"
"      internal::invoke_argument::AdlTag(),\r\n"
"      ::testing::get<k>(args)$for j [[, p$j]]);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Various overloads for ReturnNew<T>().\r\n"
"//\r\n"
"// The ReturnNew<T>(a1, a2, ..., a_k) action returns a pointer to a new\r\n"
"// instance of type T, constructed on the heap with constructor arguments\r\n"
"// a1, a2, ..., and a_k. The caller assumes ownership of the returned value.\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"$var ps = [[$for j, [[p$j]]]]\r\n"
"\r\n"
"ACTION_TEMPLATE(ReturnNew,\r\n"
"                HAS_1_TEMPLATE_PARAMS(typename, T),\r\n"
"                AND_$i[[]]_VALUE_PARAMS($ps)) {\r\n"
"  return new T($ps);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"#ifdef _MSC_VER\r\n"
"# pragma warning(pop)\r\n"
"#endif\r\n"
"\r\n"
"}  // namespace testing\r\n"
"\r\n"
"// Include any custom callback actions added by the local installation.\r\n"
"// We must include this header at the end to make sure it can use the\r\n"
"// declarations from this file.\r\n"
"#include \"gmock/internal/custom/gmock-generated-actions.h\"\r\n"
"\r\n"
"#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\r\n";

const char* gmockgeneratedactions_h_pump2 = (const char*) temp_binary_data_32;

//================== gmock-generated-function-mockers.h.pump ==================
static const unsigned char temp_binary_data_33[] =
"$$ -*- mode: c++; -*-\r\n"
"$$ This is a Pump source file.  Please use Pump to convert it to\r\n"
"$$ gmock-generated-function-mockers.h.\r\n"
"$$\r\n"
"$var n = 10  $$ The maximum arity we support.\r\n"
"// Copyright 2007, Google Inc.\r\n"
"// All rights reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: wan@google.com (Zhanyong Wan)\r\n"
"\r\n"
"// Google Mock - a framework for writing C++ mock classes.\r\n"
"//\r\n"
"// This file implements function mockers of various arities.\r\n"
"\r\n"
"#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\r\n"
"#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\r\n"
"\r\n"
"#include \"gmock/gmock-spec-builders.h\"\r\n"
"#include \"gmock/internal/gmock-internal-utils.h\"\r\n"
"\r\n"
"#if GTEST_HAS_STD_FUNCTION_\r\n"
"# include <functional>\r\n"
"#endif\r\n"
"\r\n"
"namespace testing {\r\n"
"namespace internal {\r\n"
"\r\n"
"template <typename F>\r\n"
"class FunctionMockerBase;\r\n"
"\r\n"
"// Note: class FunctionMocker really belongs to the ::testing\r\n"
"// namespace.  However if we define it in ::testing, MSVC will\r\n"
"// complain when classes in ::testing::internal declare it as a\r\n"
"// friend class template.  To workaround this compiler bug, we define\r\n"
"// FunctionMocker in ::testing::internal and import it into ::testing.\r\n"
"template <typename F>\r\n"
"class FunctionMocker;\r\n"
"\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var typename_As = [[$for j [[, typename A$j]]]]\r\n"
"$var As = [[$for j, [[A$j]]]]\r\n"
"$var as = [[$for j, [[a$j]]]]\r\n"
"$var Aas = [[$for j, [[A$j a$j]]]]\r\n"
"$var ms = [[$for j, [[m$j]]]]\r\n"
"$var matchers = [[$for j, [[const Matcher<A$j>& m$j]]]]\r\n"
"template <typename R$typename_As>\r\n"
"class FunctionMocker<R($As)> : public\r\n"
"    internal::FunctionMockerBase<R($As)> {\r\n"
" public:\r\n"
"  typedef R F($As);\r\n"
"  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\r\n"
"\r\n"
"  MockSpec<F>& With($matchers) {\r\n"
"\r\n"
"$if i >= 1 [[\r\n"
"    this->current_spec().SetMatchers(::testing::make_tuple($ms));\r\n"
"\r\n"
"]]\r\n"
"    return this->current_spec();\r\n"
"  }\r\n"
"\r\n"
"  R Invoke($Aas) {\r\n"
"    // Even though gcc and MSVC don't enforce it, 'this->' is required\r\n"
"    // by the C++ standard [14.6.4] here, as the base class type is\r\n"
"    // dependent on the template argument (and thus shouldn't be\r\n"
"    // looked into when resolving InvokeWith).\r\n"
"    return this->InvokeWith(ArgumentTuple($as));\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"}  // namespace internal\r\n"
"\r\n"
"// The style guide prohibits \"using\" statements in a namespace scope\r\n"
"// inside a header file.  However, the FunctionMocker class template\r\n"
"// is meant to be defined in the ::testing namespace.  The following\r\n"
"// line is just a trick for working around a bug in MSVC 8.0, which\r\n"
"// cannot handle it if we define FunctionMocker in ::testing.\r\n"
"using internal::FunctionMocker;\r\n"
"\r\n"
"// GMOCK_RESULT_(tn, F) expands to the result type of function type F.\r\n"
"// We define this as a variadic macro in case F contains unprotected\r\n"
"// commas (the same reason that we use variadic macros in other places\r\n"
"// in this file).\r\n"
"// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\r\n"
"#define GMOCK_RESULT_(tn, ...) \\\r\n"
"    tn ::testing::internal::Function<__VA_ARGS__>::Result\r\n"
"\r\n"
"// The type of argument N of the given function type.\r\n"
"// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\r\n"
"#define GMOCK_ARG_(tn, N, ...) \\\r\n"
"    tn ::testing::internal::Function<__VA_ARGS__>::Argument##N\r\n"
"\r\n"
"// The matcher type for argument N of the given function type.\r\n"
"// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\r\n"
"#define GMOCK_MATCHER_(tn, N, ...) \\\r\n"
"    const ::testing::Matcher<GMOCK_ARG_(tn, N, __VA_ARGS__)>&\r\n"
"\r\n"
"// The variable for mocking the given method.\r\n"
"// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\r\n"
"#define GMOCK_MOCKER_(arity, constness, Method) \\\r\n"
"    GTEST_CONCAT_TOKEN_(gmock##constness##arity##_##Method##_, __LINE__)\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var arg_as = [[$for j, \\\r\n"
"      [[GMOCK_ARG_(tn, $j, __VA_ARGS__) gmock_a$j]]]]\r\n"
"$var as = [[$for j, [[gmock_a$j]]]]\r\n"
"$var matcher_as = [[$for j, \\\r\n"
"                     [[GMOCK_MATCHER_(tn, $j, __VA_ARGS__) gmock_a$j]]]]\r\n"
"// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\r\n"
"#define GMOCK_METHOD$i[[]]_(tn, constness, ct, Method, ...) \\\r\n"
"  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\r\n"
"      $arg_as) constness { \\\r\n"
"    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\r\n"
"        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value == $i), \\\r\n"
"        this_method_does_not_take_$i[[]]_argument[[$if i != 1 [[s]]]]); \\\r\n"
"    GMOCK_MOCKER_($i, constness, Method).SetOwnerAndName(this, #Method); \\\r\n"
"    return GMOCK_MOCKER_($i, constness, Method).Invoke($as); \\\r\n"
"  } \\\r\n"
"  ::testing::MockSpec<__VA_ARGS__>& \\\r\n"
"      gmock_##Method($matcher_as) constness { \\\r\n"
"    GMOCK_MOCKER_($i, constness, Method).RegisterOwner(this); \\\r\n"
"    return GMOCK_MOCKER_($i, constness, Method).With($as); \\\r\n"
"  } \\\r\n"
"  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_($i, constness, Method)\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"$for i [[\r\n"
"#define MOCK_METHOD$i(m, ...) GMOCK_METHOD$i[[]]_(, , , m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_CONST_METHOD$i(m, ...) GMOCK_METHOD$i[[]]_(, const, , m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_METHOD$i[[]]_T(m, ...) GMOCK_METHOD$i[[]]_(typename, , , m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_CONST_METHOD$i[[]]_T(m, ...) \\\r\n"
"    GMOCK_METHOD$i[[]]_(typename, const, , m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_METHOD$i[[]]_WITH_CALLTYPE(ct, m, ...) \\\r\n"
"    GMOCK_METHOD$i[[]]_(, , ct, m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_CONST_METHOD$i[[]]_WITH_CALLTYPE(ct, m, ...) \\\r\n"
"    GMOCK_METHOD$i[[]]_(, const, ct, m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_METHOD$i[[]]_T_WITH_CALLTYPE(ct, m, ...) \\\r\n"
"    GMOCK_METHOD$i[[]]_(typename, , ct, m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"#define MOCK_CONST_METHOD$i[[]]_T_WITH_CALLTYPE(ct, m, ...) \\\r\n"
"    GMOCK_METHOD$i[[]]_(typename, const, ct, m, __VA_ARGS__)\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// A MockFunction<F> class has one mock method whose type is F.  It is\r\n"
"// useful when you just want your test code to emit some messages and\r\n"
"// have Google Mock verify the right messages are sent (and perhaps at\r\n"
"// the right times).  For example, if you are exercising code:\r\n"
"//\r\n"
"//   Foo(1);\r\n"
"//   Foo(2);\r\n"
"//   Foo(3);\r\n"
"//\r\n"
"// and want to verify that Foo(1) and Foo(3) both invoke\r\n"
"// mock.Bar(\"a\"), but Foo(2) doesn't invoke anything, you can write:\r\n"
"//\r\n"
"// TEST(FooTest, InvokesBarCorrectly) {\r\n"
"//   MyMock mock;\r\n"
"//   MockFunction<void(string check_point_name)> check;\r\n"
"//   {\r\n"
"//     InSequence s;\r\n"
"//\r\n"
"//     EXPECT_CALL(mock, Bar(\"a\"));\r\n"
"//     EXPECT_CALL(check, Call(\"1\"));\r\n"
"//     EXPECT_CALL(check, Call(\"2\"));\r\n"
"//     EXPECT_CALL(mock, Bar(\"a\"));\r\n"
"//   }\r\n"
"//   Foo(1);\r\n"
"//   check.Call(\"1\");\r\n"
"//   Foo(2);\r\n"
"//   check.Call(\"2\");\r\n"
"//   Foo(3);\r\n"
"// }\r\n"
"//\r\n"
"// The expectation spec says that the first Bar(\"a\") must happen\r\n"
"// before check point \"1\", the second Bar(\"a\") must happen after check\r\n"
"// point \"2\", and nothing should happen between the two check\r\n"
"// points. The explicit check points make it easy to tell which\r\n"
"// Bar(\"a\") is called by which call to Foo().\r\n"
"//\r\n"
"// MockFunction<F> can also be used to exercise code that accepts\r\n"
"// std::function<F> callbacks. To do so, use AsStdFunction() method\r\n"
"// to create std::function proxy forwarding to original object's Call.\r\n"
"// Example:\r\n"
"//\r\n"
"// TEST(FooTest, RunsCallbackWithBarArgument) {\r\n"
"//   MockFunction<int(string)> callback;\r\n"
"//   EXPECT_CALL(callback, Call(\"bar\")).WillOnce(Return(1));\r\n"
"//   Foo(callback.AsStdFunction());\r\n"
"// }\r\n"
"template <typename F>\r\n"
"class MockFunction;\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 0..i-1\r\n"
"$var ArgTypes = [[$for j, [[A$j]]]]\r\n"
"$var ArgNames = [[$for j, [[a$j]]]]\r\n"
"$var ArgDecls = [[$for j, [[A$j a$j]]]]\r\n"
"template <typename R$for j [[, typename A$j]]>\r\n"
"class MockFunction<R($ArgTypes)> {\r\n"
" public:\r\n"
"  MockFunction() {}\r\n"
"\r\n"
"  MOCK_METHOD$i[[]]_T(Call, R($ArgTypes));\r\n"
"\r\n"
"#if GTEST_HAS_STD_FUNCTION_\r\n"
"  std::function<R($ArgTypes)> AsStdFunction() {\r\n"
"    return [this]($ArgDecls) -> R {\r\n"
"      return this->Call($ArgNames);\r\n"
"    };\r\n"
"  }\r\n"
"#endif  // GTEST_HAS_STD_FUNCTION_\r\n"
"\r\n"
" private:\r\n"
"  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"}  // namespace testing\r\n"
"\r\n"
"#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\r\n";

const char* gmockgeneratedfunctionmockers_h_pump = (const char*) temp_binary_data_33;

//================== gmock-generated-matchers.h.pump ==================
static const unsigned char temp_binary_data_34[] =
"$$ -*- mode: c++; -*-\r\n"
"$$ This is a Pump source file.  Please use Pump to convert it to\r\n"
"$$ gmock-generated-actions.h.\r\n"
"$$\r\n"
"$var n = 10  $$ The maximum arity we support.\r\n"
"$$ }} This line fixes auto-indentation of the following code in Emacs.\r\n"
"// Copyright 2008, Google Inc.\r\n"
"// All rights reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"\r\n"
"// Google Mock - a framework for writing C++ mock classes.\r\n"
"//\r\n"
"// This file implements some commonly used variadic matchers.\r\n"
"\r\n"
"#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\r\n"
"#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\r\n"
"\r\n"
"#include <iterator>\r\n"
"#include <sstream>\r\n"
"#include <string>\r\n"
"#include <vector>\r\n"
"#include \"gmock/gmock-matchers.h\"\r\n"
"\r\n"
"namespace testing {\r\n"
"namespace internal {\r\n"
"\r\n"
"$range i 0..n-1\r\n"
"\r\n"
"// The type of the i-th (0-based) field of Tuple.\r\n"
"#define GMOCK_FIELD_TYPE_(Tuple, i) \\\r\n"
"    typename ::testing::tuple_element<i, Tuple>::type\r\n"
"\r\n"
"// TupleFields<Tuple, k0, ..., kn> is for selecting fields from a\r\n"
"// tuple of type Tuple.  It has two members:\r\n"
"//\r\n"
"//   type: a tuple type whose i-th field is the ki-th field of Tuple.\r\n"
"//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.\r\n"
"//\r\n"
"// For example, in class TupleFields<tuple<bool, char, int>, 2, 0>, we have:\r\n"
"//\r\n"
"//   type is tuple<int, bool>, and\r\n"
"//   GetSelectedFields(make_tuple(true, 'a', 42)) is (42, true).\r\n"
"\r\n"
"template <class Tuple$for i [[, int k$i = -1]]>\r\n"
"class TupleFields;\r\n"
"\r\n"
"// This generic version is used when there are $n selectors.\r\n"
"template <class Tuple$for i [[, int k$i]]>\r\n"
"class TupleFields {\r\n"
" public:\r\n"
"  typedef ::testing::tuple<$for i, [[GMOCK_FIELD_TYPE_(Tuple, k$i)]]> type;\r\n"
"  static type GetSelectedFields(const Tuple& t) {\r\n"
"    return type($for i, [[get<k$i>(t)]]);\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"// The following specialization is used for 0 ~ $(n-1) selectors.\r\n"
"\r\n"
"$for i [[\r\n"
"$$ }}}\r\n"
"$range j 0..i-1\r\n"
"$range k 0..n-1\r\n"
"\r\n"
"template <class Tuple$for j [[, int k$j]]>\r\n"
"class TupleFields<Tuple, $for k, [[$if k < i [[k$k]] $else [[-1]]]]> {\r\n"
" public:\r\n"
"  typedef ::testing::tuple<$for j, [[GMOCK_FIELD_TYPE_(Tuple, k$j)]]> type;\r\n"
"  static type GetSelectedFields(const Tuple& $if i==0 [[/* t */]] $else [[t]]) {\r\n"
"    return type($for j, [[get<k$j>(t)]]);\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"#undef GMOCK_FIELD_TYPE_\r\n"
"\r\n"
"// Implements the Args() matcher.\r\n"
"\r\n"
"$var ks = [[$for i, [[k$i]]]]\r\n"
"template <class ArgsTuple$for i [[, int k$i = -1]]>\r\n"
"class ArgsMatcherImpl : public MatcherInterface<ArgsTuple> {\r\n"
" public:\r\n"
"  // ArgsTuple may have top-level const or reference modifiers.\r\n"
"  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple;\r\n"
"  typedef typename internal::TupleFields<RawArgsTuple, $ks>::type SelectedArgs;\r\n"
"  typedef Matcher<const SelectedArgs&> MonomorphicInnerMatcher;\r\n"
"\r\n"
"  template <typename InnerMatcher>\r\n"
"  explicit ArgsMatcherImpl(const InnerMatcher& inner_matcher)\r\n"
"      : inner_matcher_(SafeMatcherCast<const SelectedArgs&>(inner_matcher)) {}\r\n"
"\r\n"
"  virtual bool MatchAndExplain(ArgsTuple args,\r\n"
"                               MatchResultListener* listener) const {\r\n"
"    const SelectedArgs& selected_args = GetSelectedArgs(args);\r\n"
"    if (!listener->IsInterested())\r\n"
"      return inner_matcher_.Matches(selected_args);\r\n"
"\r\n"
"    PrintIndices(listener->stream());\r\n"
"    *listener << \"are \" << PrintToString(selected_args);\r\n"
"\r\n"
"    StringMatchResultListener inner_listener;\r\n"
"    const bool match = inner_matcher_.MatchAndExplain(selected_args,\r\n"
"                                                      &inner_listener);\r\n"
"    PrintIfNotEmpty(inner_listener.str(), listener->stream());\r\n"
"    return match;\r\n"
"  }\r\n"
"\r\n"
"  virtual void DescribeTo(::std::ostream* os) const {\r\n"
"    *os << \"are a tuple \";\r\n"
"    PrintIndices(os);\r\n"
"    inner_matcher_.DescribeTo(os);\r\n"
"  }\r\n"
"\r\n"
"  virtual void DescribeNegationTo(::std::ostream* os) const {\r\n"
"    *os << \"are a tuple \";\r\n"
"    PrintIndices(os);\r\n"
"    inner_matcher_.DescribeNegationTo(os);\r\n"
"  }\r\n"
"\r\n"
" private:\r\n"
"  static SelectedArgs GetSelectedArgs(ArgsTuple args) {\r\n"
"    return TupleFields<RawArgsTuple, $ks>::GetSelectedFields(args);\r\n"
"  }\r\n"
"\r\n"
"  // Prints the indices of the selected fields.\r\n"
"  static void PrintIndices(::std::ostream* os) {\r\n"
"    *os << \"whose fields (\";\r\n"
"    const int indices[$n] = { $ks };\r\n"
"    for (int i = 0; i < $n; i++) {\r\n"
"      if (indices[i] < 0)\r\n"
"        break;\r\n"
"\r\n"
"      if (i >= 1)\r\n"
"        *os << \", \";\r\n"
"\r\n"
"      *os << \"#\" << indices[i];\r\n"
"    }\r\n"
"    *os << \") \";\r\n"
"  }\r\n"
"\r\n"
"  const MonomorphicInnerMatcher inner_matcher_;\r\n"
"\r\n"
"  GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl);\r\n"
"};\r\n"
"\r\n"
"template <class InnerMatcher$for i [[, int k$i = -1]]>\r\n"
"class ArgsMatcher {\r\n"
" public:\r\n"
"  explicit ArgsMatcher(const InnerMatcher& inner_matcher)\r\n"
"      : inner_matcher_(inner_matcher) {}\r\n"
"\r\n"
"  template <typename ArgsTuple>\r\n"
"  operator Matcher<ArgsTuple>() const {\r\n"
"    return MakeMatcher(new ArgsMatcherImpl<ArgsTuple, $ks>(inner_matcher_));\r\n"
"  }\r\n"
"\r\n"
" private:\r\n"
"  const InnerMatcher inner_matcher_;\r\n"
"\r\n"
"  GTEST_DISALLOW_ASSIGN_(ArgsMatcher);\r\n"
"};\r\n"
"\r\n"
"// A set of metafunctions for computing the result type of AllOf.\r\n"
"// AllOf(m1, ..., mN) returns\r\n"
"// AllOfResultN<decltype(m1), ..., decltype(mN)>::type.\r\n"
"\r\n"
"// Although AllOf isn't defined for one argument, AllOfResult1 is defined\r\n"
"// to simplify the implementation.\r\n"
"template <typename M1>\r\n"
"struct AllOfResult1 {\r\n"
"  typedef M1 type;\r\n"
"};\r\n"
"\r\n"
"$range i 1..n\r\n"
"\r\n"
"$range i 2..n\r\n"
"$for i [[\r\n"
"$range j 2..i\r\n"
"$var m = i/2\r\n"
"$range k 1..m\r\n"
"$range t m+1..i\r\n"
"\r\n"
"template <typename M1$for j [[, typename M$j]]>\r\n"
"struct AllOfResult$i {\r\n"
"  typedef BothOfMatcher<\r\n"
"      typename AllOfResult$m<$for k, [[M$k]]>::type,\r\n"
"      typename AllOfResult$(i-m)<$for t, [[M$t]]>::type\r\n"
"  > type;\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// A set of metafunctions for computing the result type of AnyOf.\r\n"
"// AnyOf(m1, ..., mN) returns\r\n"
"// AnyOfResultN<decltype(m1), ..., decltype(mN)>::type.\r\n"
"\r\n"
"// Although AnyOf isn't defined for one argument, AnyOfResult1 is defined\r\n"
"// to simplify the implementation.\r\n"
"template <typename M1>\r\n"
"struct AnyOfResult1 {\r\n"
"  typedef M1 type;\r\n"
"};\r\n"
"\r\n"
"$range i 1..n\r\n"
"\r\n"
"$range i 2..n\r\n"
"$for i [[\r\n"
"$range j 2..i\r\n"
"$var m = i/2\r\n"
"$range k 1..m\r\n"
"$range t m+1..i\r\n"
"\r\n"
"template <typename M1$for j [[, typename M$j]]>\r\n"
"struct AnyOfResult$i {\r\n"
"  typedef EitherOfMatcher<\r\n"
"      typename AnyOfResult$m<$for k, [[M$k]]>::type,\r\n"
"      typename AnyOfResult$(i-m)<$for t, [[M$t]]>::type\r\n"
"  > type;\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"}  // namespace internal\r\n"
"\r\n"
"// Args<N1, N2, ..., Nk>(a_matcher) matches a tuple if the selected\r\n"
"// fields of it matches a_matcher.  C++ doesn't support default\r\n"
"// arguments for function templates, so we have to overload it.\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"template <$for j [[int k$j, ]]typename InnerMatcher>\r\n"
"inline internal::ArgsMatcher<InnerMatcher$for j [[, k$j]]>\r\n"
"Args(const InnerMatcher& matcher) {\r\n"
"  return internal::ArgsMatcher<InnerMatcher$for j [[, k$j]]>(matcher);\r\n"
"}\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with\r\n"
"// n elements, where the i-th element in the container must\r\n"
"// match the i-th argument in the list.  Each argument of\r\n"
"// ElementsAre() can be either a value or a matcher.  We support up to\r\n"
"// $n arguments.\r\n"
"//\r\n"
"// The use of DecayArray in the implementation allows ElementsAre()\r\n"
"// to accept string literals, whose type is const char[N], but we\r\n"
"// want to treat them as const char*.\r\n"
"//\r\n"
"// NOTE: Since ElementsAre() cares about the order of the elements, it\r\n"
"// must not be used with containers whose elements's order is\r\n"
"// undefined (e.g. hash_map).\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"\r\n"
"$range j 1..i\r\n"
"\r\n"
"$if i>0 [[\r\n"
"\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"]]\r\n"
"\r\n"
"inline internal::ElementsAreMatcher<\r\n"
"    ::testing::tuple<\r\n"
"$for j, [[\r\n"
"\r\n"
"        typename internal::DecayArray<T$j[[]]>::type]]> >\r\n"
"ElementsAre($for j, [[const T$j& e$j]]) {\r\n"
"  typedef ::testing::tuple<\r\n"
"$for j, [[\r\n"
"\r\n"
"      typename internal::DecayArray<T$j[[]]>::type]]> Args;\r\n"
"  return internal::ElementsAreMatcher<Args>(Args($for j, [[e$j]]));\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension\r\n"
"// that matches n elements in any order.  We support up to n=$n arguments.\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i [[\r\n"
"\r\n"
"$range j 1..i\r\n"
"\r\n"
"$if i>0 [[\r\n"
"\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"]]\r\n"
"\r\n"
"inline internal::UnorderedElementsAreMatcher<\r\n"
"    ::testing::tuple<\r\n"
"$for j, [[\r\n"
"\r\n"
"        typename internal::DecayArray<T$j[[]]>::type]]> >\r\n"
"UnorderedElementsAre($for j, [[const T$j& e$j]]) {\r\n"
"  typedef ::testing::tuple<\r\n"
"$for j, [[\r\n"
"\r\n"
"      typename internal::DecayArray<T$j[[]]>::type]]> Args;\r\n"
"  return internal::UnorderedElementsAreMatcher<Args>(Args($for j, [[e$j]]));\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// AllOf(m1, m2, ..., mk) matches any value that matches all of the given\r\n"
"// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.\r\n"
"\r\n"
"$range i 2..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var m = i/2\r\n"
"$range k 1..m\r\n"
"$range t m+1..i\r\n"
"\r\n"
"template <$for j, [[typename M$j]]>\r\n"
"inline typename internal::AllOfResult$i<$for j, [[M$j]]>::type\r\n"
"AllOf($for j, [[M$j m$j]]) {\r\n"
"  return typename internal::AllOfResult$i<$for j, [[M$j]]>::type(\r\n"
"      $if m == 1 [[m1]] $else [[::testing::AllOf($for k, [[m$k]])]],\r\n"
"      $if m+1 == i [[m$i]] $else [[::testing::AllOf($for t, [[m$t]])]]);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given\r\n"
"// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.\r\n"
"\r\n"
"$range i 2..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$var m = i/2\r\n"
"$range k 1..m\r\n"
"$range t m+1..i\r\n"
"\r\n"
"template <$for j, [[typename M$j]]>\r\n"
"inline typename internal::AnyOfResult$i<$for j, [[M$j]]>::type\r\n"
"AnyOf($for j, [[M$j m$j]]) {\r\n"
"  return typename internal::AnyOfResult$i<$for j, [[M$j]]>::type(\r\n"
"      $if m == 1 [[m1]] $else [[::testing::AnyOf($for k, [[m$k]])]],\r\n"
"      $if m+1 == i [[m$i]] $else [[::testing::AnyOf($for t, [[m$t]])]]);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"}  // namespace testing\r\n"
"$$ } // This Pump meta comment fixes auto-indentation in Emacs. It will not\r\n"
"$$   // show up in the generated code.\r\n"
"\r\n"
"\r\n"
"// The MATCHER* family of macros can be used in a namespace scope to\r\n"
"// define custom matchers easily.\r\n"
"//\r\n"
"// Basic Usage\r\n"
"// ===========\r\n"
"//\r\n"
"// The syntax\r\n"
"//\r\n"
"//   MATCHER(name, description_string) { statements; }\r\n"
"//\r\n"
"// defines a matcher with the given name that executes the statements,\r\n"
"// which must return a bool to indicate if the match succeeds.  Inside\r\n"
"// the statements, you can refer to the value being matched by 'arg',\r\n"
"// and refer to its type by 'arg_type'.\r\n"
"//\r\n"
"// The description string documents what the matcher does, and is used\r\n"
"// to generate the failure message when the match fails.  Since a\r\n"
"// MATCHER() is usually defined in a header file shared by multiple\r\n"
"// C++ source files, we require the description to be a C-string\r\n"
"// literal to avoid possible side effects.  It can be empty, in which\r\n"
"// case we'll use the sequence of words in the matcher name as the\r\n"
"// description.\r\n"
"//\r\n"
"// For example:\r\n"
"//\r\n"
"//   MATCHER(IsEven, \"\") { return (arg % 2) == 0; }\r\n"
"//\r\n"
"// allows you to write\r\n"
"//\r\n"
"//   // Expects mock_foo.Bar(n) to be called where n is even.\r\n"
"//   EXPECT_CALL(mock_foo, Bar(IsEven()));\r\n"
"//\r\n"
"// or,\r\n"
"//\r\n"
"//   // Verifies that the value of some_expression is even.\r\n"
"//   EXPECT_THAT(some_expression, IsEven());\r\n"
"//\r\n"
"// If the above assertion fails, it will print something like:\r\n"
"//\r\n"
"//   Value of: some_expression\r\n"
"//   Expected: is even\r\n"
"//     Actual: 7\r\n"
"//\r\n"
"// where the description \"is even\" is automatically calculated from the\r\n"
"// matcher name IsEven.\r\n"
"//\r\n"
"// Argument Type\r\n"
"// =============\r\n"
"//\r\n"
"// Note that the type of the value being matched (arg_type) is\r\n"
"// determined by the context in which you use the matcher and is\r\n"
"// supplied to you by the compiler, so you don't need to worry about\r\n"
"// declaring it (nor can you).  This allows the matcher to be\r\n"
"// polymorphic.  For example, IsEven() can be used to match any type\r\n"
"// where the value of \"(arg % 2) == 0\" can be implicitly converted to\r\n"
"// a bool.  In the \"Bar(IsEven())\" example above, if method Bar()\r\n"
"// takes an int, 'arg_type' will be int; if it takes an unsigned long,\r\n"
"// 'arg_type' will be unsigned long; and so on.\r\n"
"//\r\n"
"// Parameterizing Matchers\r\n"
"// =======================\r\n"
"//\r\n"
"// Sometimes you'll want to parameterize the matcher.  For that you\r\n"
"// can use another macro:\r\n"
"//\r\n"
"//   MATCHER_P(name, param_name, description_string) { statements; }\r\n"
"//\r\n"
"// For example:\r\n"
"//\r\n"
"//   MATCHER_P(HasAbsoluteValue, value, \"\") { return abs(arg) == value; }\r\n"
"//\r\n"
"// will allow you to write:\r\n"
"//\r\n"
"//   EXPECT_THAT(Blah(\"a\"), HasAbsoluteValue(n));\r\n"
"//\r\n"
"// which may lead to this message (assuming n is 10):\r\n"
"//\r\n"
"//   Value of: Blah(\"a\")\r\n"
"//   Expected: has absolute value 10\r\n"
"//     Actual: -9\r\n"
"//\r\n"
"// Note that both the matcher description and its parameter are\r\n"
"// printed, making the message human-friendly.\r\n"
"//\r\n"
"// In the matcher definition body, you can write 'foo_type' to\r\n"
"// reference the type of a parameter named 'foo'.  For example, in the\r\n"
"// body of MATCHER_P(HasAbsoluteValue, value) above, you can write\r\n"
"// 'value_type' to refer to the type of 'value'.\r\n"
"//\r\n"
"// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P$n to\r\n"
"// support multi-parameter matchers.\r\n"
"//\r\n"
"// Describing Parameterized Matchers\r\n"
"// =================================\r\n"
"//\r\n"
"// The last argument to MATCHER*() is a string-typed expression.  The\r\n"
"// expression can reference all of the matcher's parameters and a\r\n"
"// special bool-typed variable named 'negation'.  When 'negation' is\r\n"
"// false, the expression should evaluate to the matcher's description;\r\n"
"// otherwise it should evaluate to the description of the negation of\r\n"
"// the matcher.  For example,\r\n"
"//\r\n"
"//   using testing::PrintToString;\r\n"
"//\r\n"
"//   MATCHER_P2(InClosedRange, low, hi,\r\n"
"//       string(negation ? \"is not\" : \"is\") + \" in range [\" +\r\n"
"//       PrintToString(low) + \", \" + PrintToString(hi) + \"]\") {\r\n"
"//     return low <= arg && arg <= hi;\r\n"
"//   }\r\n"
"//   ...\r\n"
"//   EXPECT_THAT(3, InClosedRange(4, 6));\r\n"
"//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\r\n"
"//\r\n"
"// would generate two failures that contain the text:\r\n"
"//\r\n"
"//   Expected: is in range [4, 6]\r\n"
"//   ...\r\n"
"//   Expected: is not in range [2, 4]\r\n"
"//\r\n"
"// If you specify \"\" as the description, the failure message will\r\n"
"// contain the sequence of words in the matcher name followed by the\r\n"
"// parameter values printed as a tuple.  For example,\r\n"
"//\r\n"
"//   MATCHER_P2(InClosedRange, low, hi, \"\") { ... }\r\n"
"//   ...\r\n"
"//   EXPECT_THAT(3, InClosedRange(4, 6));\r\n"
"//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\r\n"
"//\r\n"
"// would generate two failures that contain the text:\r\n"
"//\r\n"
"//   Expected: in closed range (4, 6)\r\n"
"//   ...\r\n"
"//   Expected: not (in closed range (2, 4))\r\n"
"//\r\n"
"// Types of Matcher Parameters\r\n"
"// ===========================\r\n"
"//\r\n"
"// For the purpose of typing, you can view\r\n"
"//\r\n"
"//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\r\n"
"//\r\n"
"// as shorthand for\r\n"
"//\r\n"
"//   template <typename p1_type, ..., typename pk_type>\r\n"
"//   FooMatcherPk<p1_type, ..., pk_type>\r\n"
"//   Foo(p1_type p1, ..., pk_type pk) { ... }\r\n"
"//\r\n"
"// When you write Foo(v1, ..., vk), the compiler infers the types of\r\n"
"// the parameters v1, ..., and vk for you.  If you are not happy with\r\n"
"// the result of the type inference, you can specify the types by\r\n"
"// explicitly instantiating the template, as in Foo<long, bool>(5,\r\n"
"// false).  As said earlier, you don't get to (or need to) specify\r\n"
"// 'arg_type' as that's determined by the context in which the matcher\r\n"
"// is used.  You can assign the result of expression Foo(p1, ..., pk)\r\n"
"// to a variable of type FooMatcherPk<p1_type, ..., pk_type>.  This\r\n"
"// can be useful when composing matchers.\r\n"
"//\r\n"
"// While you can instantiate a matcher template with reference types,\r\n"
"// passing the parameters by pointer usually makes your code more\r\n"
"// readable.  If, however, you still want to pass a parameter by\r\n"
"// reference, be aware that in the failure message generated by the\r\n"
"// matcher you will see the value of the referenced object but not its\r\n"
"// address.\r\n"
"//\r\n"
"// Explaining Match Results\r\n"
"// ========================\r\n"
"//\r\n"
"// Sometimes the matcher description alone isn't enough to explain why\r\n"
"// the match has failed or succeeded.  For example, when expecting a\r\n"
"// long string, it can be very helpful to also print the diff between\r\n"
"// the expected string and the actual one.  To achieve that, you can\r\n"
"// optionally stream additional information to a special variable\r\n"
"// named result_listener, whose type is a pointer to class\r\n"
"// MatchResultListener:\r\n"
"//\r\n"
"//   MATCHER_P(EqualsLongString, str, \"\") {\r\n"
"//     if (arg == str) return true;\r\n"
"//\r\n"
"//     *result_listener << \"the difference: \"\r\n"
"///                     << DiffStrings(str, arg);\r\n"
"//     return false;\r\n"
"//   }\r\n"
"//\r\n"
"// Overloading Matchers\r\n"
"// ====================\r\n"
"//\r\n"
"// You can overload matchers with different numbers of parameters:\r\n"
"//\r\n"
"//   MATCHER_P(Blah, a, description_string1) { ... }\r\n"
"//   MATCHER_P2(Blah, a, b, description_string2) { ... }\r\n"
"//\r\n"
"// Caveats\r\n"
"// =======\r\n"
"//\r\n"
"// When defining a new matcher, you should also consider implementing\r\n"
"// MatcherInterface or using MakePolymorphicMatcher().  These\r\n"
"// approaches require more work than the MATCHER* macros, but also\r\n"
"// give you more control on the types of the value being matched and\r\n"
"// the matcher parameters, which may leads to better compiler error\r\n"
"// messages when the matcher is used wrong.  They also allow\r\n"
"// overloading matchers based on parameter types (as opposed to just\r\n"
"// based on the number of parameters).\r\n"
"//\r\n"
"// MATCHER*() can only be used in a namespace scope.  The reason is\r\n"
"// that C++ doesn't yet allow function-local types to be used to\r\n"
"// instantiate templates.  The up-coming C++0x standard will fix this.\r\n"
"// Once that's done, we'll consider supporting using MATCHER*() inside\r\n"
"// a function.\r\n"
"//\r\n"
"// More Information\r\n"
"// ================\r\n"
"//\r\n"
"// To learn more about using these macros, please search for 'MATCHER'\r\n"
"// on http://code.google.com/p/googlemock/wiki/CookBook.\r\n"
"\r\n"
"$range i 0..n\r\n"
"$for i\r\n"
"\r\n"
"[[\r\n"
"$var macro_name = [[$if i==0 [[MATCHER]] $elif i==1 [[MATCHER_P]]\r\n"
"                                         $else [[MATCHER_P$i]]]]\r\n"
"$var class_name = [[name##Matcher[[$if i==0 [[]] $elif i==1 [[P]]\r\n"
"                                                 $else [[P$i]]]]]]\r\n"
"$range j 0..i-1\r\n"
"$var template = [[$if i==0 [[]] $else [[\r\n"
"\r\n"
"  template <$for j, [[typename p$j##_type]]>\\\r\n"
"]]]]\r\n"
"$var ctor_param_list = [[$for j, [[p$j##_type gmock_p$j]]]]\r\n"
"$var impl_ctor_param_list = [[$for j, [[p$j##_type gmock_p$j]]]]\r\n"
"$var impl_inits = [[$if i==0 [[]] $else [[ : $for j, [[p$j(gmock_p$j)]]]]]]\r\n"
"$var inits = [[$if i==0 [[]] $else [[ : $for j, [[p$j(gmock_p$j)]]]]]]\r\n"
"$var params = [[$for j, [[p$j]]]]\r\n"
"$var param_types = [[$if i==0 [[]] $else [[<$for j, [[p$j##_type]]>]]]]\r\n"
"$var param_types_and_names = [[$for j, [[p$j##_type p$j]]]]\r\n"
"$var param_field_decls = [[$for j\r\n"
"[[\r\n"
"\r\n"
"      p$j##_type p$j;\\\r\n"
"]]]]\r\n"
"$var param_field_decls2 = [[$for j\r\n"
"[[\r\n"
"\r\n"
"    p$j##_type p$j;\\\r\n"
"]]]]\r\n"
"\r\n"
"#define $macro_name(name$for j [[, p$j]], description)\\$template\r\n"
"  class $class_name {\\\r\n"
"   public:\\\r\n"
"    template <typename arg_type>\\\r\n"
"    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\r\n"
"     public:\\\r\n"
"      [[$if i==1 [[explicit ]]]]gmock_Impl($impl_ctor_param_list)\\\r\n"
"          $impl_inits {}\\\r\n"
"      virtual bool MatchAndExplain(\\\r\n"
"          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\r\n"
"      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\r\n"
"        *gmock_os << FormatDescription(false);\\\r\n"
"      }\\\r\n"
"      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\r\n"
"        *gmock_os << FormatDescription(true);\\\r\n"
"      }\\$param_field_decls\r\n"
"     private:\\\r\n"
"      ::testing::internal::string FormatDescription(bool negation) const {\\\r\n"
"        const ::testing::internal::string gmock_description = (description);\\\r\n"
"        if (!gmock_description.empty())\\\r\n"
"          return gmock_description;\\\r\n"
"        return ::testing::internal::FormatMatcherDescription(\\\r\n"
"            negation, #name, \\\r\n"
"            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\r\n"
"                ::testing::tuple<$for j, [[p$j##_type]]>($for j, [[p$j]])));\\\r\n"
"      }\\\r\n"
"      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\r\n"
"    };\\\r\n"
"    template <typename arg_type>\\\r\n"
"    operator ::testing::Matcher<arg_type>() const {\\\r\n"
"      return ::testing::Matcher<arg_type>(\\\r\n"
"          new gmock_Impl<arg_type>($params));\\\r\n"
"    }\\\r\n"
"    [[$if i==1 [[explicit ]]]]$class_name($ctor_param_list)$inits {\\\r\n"
"    }\\$param_field_decls2\r\n"
"   private:\\\r\n"
"    GTEST_DISALLOW_ASSIGN_($class_name);\\\r\n"
"  };\\$template\r\n"
"  inline $class_name$param_types name($param_types_and_names) {\\\r\n"
"    return $class_name$param_types($params);\\\r\n"
"  }\\$template\r\n"
"  template <typename arg_type>\\\r\n"
"  bool $class_name$param_types::gmock_Impl<arg_type>::MatchAndExplain(\\\r\n"
"      arg_type arg, \\\r\n"
"      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\r\n"
"          const\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\r\n";

const char* gmockgeneratedmatchers_h_pump = (const char*) temp_binary_data_34;

//================== gmock-generated-nice-strict.h.pump ==================
static const unsigned char temp_binary_data_35[] =
"$$ -*- mode: c++; -*-\r\n"
"$$ This is a Pump source file.  Please use Pump to convert it to\r\n"
"$$ gmock-generated-nice-strict.h.\r\n"
"$$\r\n"
"$var n = 10  $$ The maximum arity we support.\r\n"
"// Copyright 2008, Google Inc.\r\n"
"// All rights reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: wan@google.com (Zhanyong Wan)\r\n"
"\r\n"
"// Implements class templates NiceMock, NaggyMock, and StrictMock.\r\n"
"//\r\n"
"// Given a mock class MockFoo that is created using Google Mock,\r\n"
"// NiceMock<MockFoo> is a subclass of MockFoo that allows\r\n"
"// uninteresting calls (i.e. calls to mock methods that have no\r\n"
"// EXPECT_CALL specs), NaggyMock<MockFoo> is a subclass of MockFoo\r\n"
"// that prints a warning when an uninteresting call occurs, and\r\n"
"// StrictMock<MockFoo> is a subclass of MockFoo that treats all\r\n"
"// uninteresting calls as errors.\r\n"
"//\r\n"
"// Currently a mock is naggy by default, so MockFoo and\r\n"
"// NaggyMock<MockFoo> behave like the same.  However, we will soon\r\n"
"// switch the default behavior of mocks to be nice, as that in general\r\n"
"// leads to more maintainable tests.  When that happens, MockFoo will\r\n"
"// stop behaving like NaggyMock<MockFoo> and start behaving like\r\n"
"// NiceMock<MockFoo>.\r\n"
"//\r\n"
"// NiceMock, NaggyMock, and StrictMock \"inherit\" the constructors of\r\n"
"// their respective base class, with up-to $n arguments.  Therefore\r\n"
"// you can write NiceMock<MockFoo>(5, \"a\") to construct a nice mock\r\n"
"// where MockFoo has a constructor that accepts (int, const char*),\r\n"
"// for example.\r\n"
"//\r\n"
"// A known limitation is that NiceMock<MockFoo>, NaggyMock<MockFoo>,\r\n"
"// and StrictMock<MockFoo> only works for mock methods defined using\r\n"
"// the MOCK_METHOD* family of macros DIRECTLY in the MockFoo class.\r\n"
"// If a mock method is defined in a base class of MockFoo, the \"nice\"\r\n"
"// or \"strict\" modifier may not affect it, depending on the compiler.\r\n"
"// In particular, nesting NiceMock, NaggyMock, and StrictMock is NOT\r\n"
"// supported.\r\n"
"//\r\n"
"// Another known limitation is that the constructors of the base mock\r\n"
"// cannot have arguments passed by non-const reference, which are\r\n"
"// banned by the Google C++ style guide anyway.\r\n"
"\r\n"
"#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\r\n"
"#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\r\n"
"\r\n"
"#include \"gmock/gmock-spec-builders.h\"\r\n"
"#include \"gmock/internal/gmock-port.h\"\r\n"
"\r\n"
"namespace testing {\r\n"
"\r\n"
"$range kind 0..2\r\n"
"$for kind [[\r\n"
"\r\n"
"$var clazz=[[$if kind==0 [[NiceMock]]\r\n"
"             $elif kind==1 [[NaggyMock]]\r\n"
"             $else [[StrictMock]]]]\r\n"
"\r\n"
"$var method=[[$if kind==0 [[AllowUninterestingCalls]]\r\n"
"             $elif kind==1 [[WarnUninterestingCalls]]\r\n"
"             $else [[FailUninterestingCalls]]]]\r\n"
"\r\n"
"template <class MockClass>\r\n"
"class $clazz : public MockClass {\r\n"
" public:\r\n"
"  // We don't factor out the constructor body to a common method, as\r\n"
"  // we have to avoid a possible clash with members of MockClass.\r\n"
"  $clazz() {\r\n"
"    ::testing::Mock::$method(\r\n"
"        internal::ImplicitCast_<MockClass*>(this));\r\n"
"  }\r\n"
"\r\n"
"  // C++ doesn't (yet) allow inheritance of constructors, so we have\r\n"
"  // to define it for each arity.\r\n"
"  template <typename A1>\r\n"
"  explicit $clazz(const A1& a1) : MockClass(a1) {\r\n"
"    ::testing::Mock::$method(\r\n"
"        internal::ImplicitCast_<MockClass*>(this));\r\n"
"  }\r\n"
"\r\n"
"$range i 2..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"  template <$for j, [[typename A$j]]>\r\n"
"  $clazz($for j, [[const A$j& a$j]]) : MockClass($for j, [[a$j]]) {\r\n"
"    ::testing::Mock::$method(\r\n"
"        internal::ImplicitCast_<MockClass*>(this));\r\n"
"  }\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"  virtual ~$clazz() {\r\n"
"    ::testing::Mock::UnregisterCallReaction(\r\n"
"        internal::ImplicitCast_<MockClass*>(this));\r\n"
"  }\r\n"
"\r\n"
" private:\r\n"
"  GTEST_DISALLOW_COPY_AND_ASSIGN_($clazz);\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// The following specializations catch some (relatively more common)\r\n"
"// user errors of nesting nice and strict mocks.  They do NOT catch\r\n"
"// all possible errors.\r\n"
"\r\n"
"// These specializations are declared but not defined, as NiceMock,\r\n"
"// NaggyMock, and StrictMock cannot be nested.\r\n"
"\r\n"
"template <typename MockClass>\r\n"
"class NiceMock<NiceMock<MockClass> >;\r\n"
"template <typename MockClass>\r\n"
"class NiceMock<NaggyMock<MockClass> >;\r\n"
"template <typename MockClass>\r\n"
"class NiceMock<StrictMock<MockClass> >;\r\n"
"\r\n"
"template <typename MockClass>\r\n"
"class NaggyMock<NiceMock<MockClass> >;\r\n"
"template <typename MockClass>\r\n"
"class NaggyMock<NaggyMock<MockClass> >;\r\n"
"template <typename MockClass>\r\n"
"class NaggyMock<StrictMock<MockClass> >;\r\n"
"\r\n"
"template <typename MockClass>\r\n"
"class StrictMock<NiceMock<MockClass> >;\r\n"
"template <typename MockClass>\r\n"
"class StrictMock<NaggyMock<MockClass> >;\r\n"
"template <typename MockClass>\r\n"
"class StrictMock<StrictMock<MockClass> >;\r\n"
"\r\n"
"}  // namespace testing\r\n"
"\r\n"
"#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\r\n";

const char* gmockgeneratednicestrict_h_pump = (const char*) temp_binary_data_35;

//================== gtest-param-util-generated.h.pump ==================
static const unsigned char temp_binary_data_36[] =
"$$ -*- mode: c++; -*-\r\n"
"$var n = 50  $$ Maximum length of Values arguments we want to support.\r\n"
"$var maxtuple = 10  $$ Maximum number of Combine arguments we want to support.\r\n"
"// Copyright 2008 Google Inc.\r\n"
"// All Rights Reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: vladl@google.com (Vlad Losev)\r\n"
"\r\n"
"// Type and function utilities for implementing parameterized tests.\r\n"
"// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\r\n"
"//\r\n"
"// Currently Google Test supports at most $n arguments in Values,\r\n"
"// and at most $maxtuple arguments in Combine. Please contact\r\n"
"// googletestframework@googlegroups.com if you need more.\r\n"
"// Please note that the number of arguments to Combine is limited\r\n"
"// by the maximum arity of the implementation of tuple which is\r\n"
"// currently set at $maxtuple.\r\n"
"\r\n"
"#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\r\n"
"#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\r\n"
"\r\n"
"// scripts/fuse_gtest.py depends on gtest's own header being #included\r\n"
"// *unconditionally*.  Therefore these #includes cannot be moved\r\n"
"// inside #if GTEST_HAS_PARAM_TEST.\r\n"
"#include \"gtest/internal/gtest-param-util.h\"\r\n"
"#include \"gtest/internal/gtest-port.h\"\r\n"
"\r\n"
"#if GTEST_HAS_PARAM_TEST\r\n"
"\r\n"
"namespace testing {\r\n"
"\r\n"
"// Forward declarations of ValuesIn(), which is implemented in\r\n"
"// include/gtest/gtest-param-test.h.\r\n"
"template <typename ForwardIterator>\r\n"
"internal::ParamGenerator<\r\n"
"  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\r\n"
"ValuesIn(ForwardIterator begin, ForwardIterator end);\r\n"
"\r\n"
"template <typename T, size_t N>\r\n"
"internal::ParamGenerator<T> ValuesIn(const T (&array)[N]);\r\n"
"\r\n"
"template <class Container>\r\n"
"internal::ParamGenerator<typename Container::value_type> ValuesIn(\r\n"
"    const Container& container);\r\n"
"\r\n"
"namespace internal {\r\n"
"\r\n"
"// Used in the Values() function to provide polymorphic capabilities.\r\n"
"$range i 1..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"class ValueArray$i {\r\n"
" public:\r\n"
"  $if i==1 [[explicit ]]ValueArray$i($for j, [[T$j v$j]]) : $for j, [[v$(j)_(v$j)]] {}\r\n"
"\r\n"
"  template <typename T>\r\n"
"  operator ParamGenerator<T>() const {\r\n"
"    const T array[] = {$for j, [[static_cast<T>(v$(j)_)]]};\r\n"
"    return ValuesIn(array);\r\n"
"  }\r\n"
"\r\n"
" private:\r\n"
"  // No implementation - assignment is unsupported.\r\n"
"  void operator=(const ValueArray$i& other);\r\n"
"\r\n"
"$for j [[\r\n"
"\r\n"
"  const T$j v$(j)_;\r\n"
"]]\r\n"
"\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"# if GTEST_HAS_COMBINE\r\n"
"// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\r\n"
"//\r\n"
"// Generates values from the Cartesian product of values produced\r\n"
"// by the argument generators.\r\n"
"//\r\n"
"$range i 2..maxtuple\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$range k 2..i\r\n"
"\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"class CartesianProductGenerator$i\r\n"
"    : public ParamGeneratorInterface< ::testing::tuple<$for j, [[T$j]]> > {\r\n"
" public:\r\n"
"  typedef ::testing::tuple<$for j, [[T$j]]> ParamType;\r\n"
"\r\n"
"  CartesianProductGenerator$i($for j, [[const ParamGenerator<T$j>& g$j]])\r\n"
"      : $for j, [[g$(j)_(g$j)]] {}\r\n"
"  virtual ~CartesianProductGenerator$i() {}\r\n"
"\r\n"
"  virtual ParamIteratorInterface<ParamType>* Begin() const {\r\n"
"    return new Iterator(this, $for j, [[g$(j)_, g$(j)_.begin()]]);\r\n"
"  }\r\n"
"  virtual ParamIteratorInterface<ParamType>* End() const {\r\n"
"    return new Iterator(this, $for j, [[g$(j)_, g$(j)_.end()]]);\r\n"
"  }\r\n"
"\r\n"
" private:\r\n"
"  class Iterator : public ParamIteratorInterface<ParamType> {\r\n"
"   public:\r\n"
"    Iterator(const ParamGeneratorInterface<ParamType>* base, $for j, [[\r\n"
"\r\n"
"      const ParamGenerator<T$j>& g$j,\r\n"
"      const typename ParamGenerator<T$j>::iterator& current$(j)]])\r\n"
"        : base_(base),\r\n"
"$for j, [[\r\n"
"\r\n"
"          begin$(j)_(g$j.begin()), end$(j)_(g$j.end()), current$(j)_(current$j)\r\n"
"]]    {\r\n"
"      ComputeCurrentValue();\r\n"
"    }\r\n"
"    virtual ~Iterator() {}\r\n"
"\r\n"
"    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\r\n"
"      return base_;\r\n"
"    }\r\n"
"    // Advance should not be called on beyond-of-range iterators\r\n"
"    // so no component iterators must be beyond end of range, either.\r\n"
"    virtual void Advance() {\r\n"
"      assert(!AtEnd());\r\n"
"      ++current$(i)_;\r\n"
"\r\n"
"$for k [[\r\n"
"      if (current$(i+2-k)_ == end$(i+2-k)_) {\r\n"
"        current$(i+2-k)_ = begin$(i+2-k)_;\r\n"
"        ++current$(i+2-k-1)_;\r\n"
"      }\r\n"
"\r\n"
"]]\r\n"
"      ComputeCurrentValue();\r\n"
"    }\r\n"
"    virtual ParamIteratorInterface<ParamType>* Clone() const {\r\n"
"      return new Iterator(*this);\r\n"
"    }\r\n"
"    virtual const ParamType* Current() const { return &current_value_; }\r\n"
"    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\r\n"
"      // Having the same base generator guarantees that the other\r\n"
"      // iterator is of the same type and we can downcast.\r\n"
"      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\r\n"
"          << \"The program attempted to compare iterators \"\r\n"
"          << \"from different generators.\" << std::endl;\r\n"
"      const Iterator* typed_other =\r\n"
"          CheckedDowncastToActualType<const Iterator>(&other);\r\n"
"      // We must report iterators equal if they both point beyond their\r\n"
"      // respective ranges. That can happen in a variety of fashions,\r\n"
"      // so we have to consult AtEnd().\r\n"
"      return (AtEnd() && typed_other->AtEnd()) ||\r\n"
"         ($for j  && [[\r\n"
"\r\n"
"          current$(j)_ == typed_other->current$(j)_\r\n"
"]]);\r\n"
"    }\r\n"
"\r\n"
"   private:\r\n"
"    Iterator(const Iterator& other)\r\n"
"        : base_(other.base_), $for j, [[\r\n"
"\r\n"
"        begin$(j)_(other.begin$(j)_),\r\n"
"        end$(j)_(other.end$(j)_),\r\n"
"        current$(j)_(other.current$(j)_)\r\n"
"]] {\r\n"
"      ComputeCurrentValue();\r\n"
"    }\r\n"
"\r\n"
"    void ComputeCurrentValue() {\r\n"
"      if (!AtEnd())\r\n"
"        current_value_ = ParamType($for j, [[*current$(j)_]]);\r\n"
"    }\r\n"
"    bool AtEnd() const {\r\n"
"      // We must report iterator past the end of the range when either of the\r\n"
"      // component iterators has reached the end of its range.\r\n"
"      return\r\n"
"$for j  || [[\r\n"
"\r\n"
"          current$(j)_ == end$(j)_\r\n"
"]];\r\n"
"    }\r\n"
"\r\n"
"    // No implementation - assignment is unsupported.\r\n"
"    void operator=(const Iterator& other);\r\n"
"\r\n"
"    const ParamGeneratorInterface<ParamType>* const base_;\r\n"
"    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\r\n"
"    // current[i]_ is the actual traversing iterator.\r\n"
"$for j [[\r\n"
"\r\n"
"    const typename ParamGenerator<T$j>::iterator begin$(j)_;\r\n"
"    const typename ParamGenerator<T$j>::iterator end$(j)_;\r\n"
"    typename ParamGenerator<T$j>::iterator current$(j)_;\r\n"
"]]\r\n"
"\r\n"
"    ParamType current_value_;\r\n"
"  };  // class CartesianProductGenerator$i::Iterator\r\n"
"\r\n"
"  // No implementation - assignment is unsupported.\r\n"
"  void operator=(const CartesianProductGenerator$i& other);\r\n"
"\r\n"
"\r\n"
"$for j [[\r\n"
"  const ParamGenerator<T$j> g$(j)_;\r\n"
"\r\n"
"]]\r\n"
"};  // class CartesianProductGenerator$i\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\r\n"
"//\r\n"
"// Helper classes providing Combine() with polymorphic features. They allow\r\n"
"// casting CartesianProductGeneratorN<T> to ParamGenerator<U> if T is\r\n"
"// convertible to U.\r\n"
"//\r\n"
"$range i 2..maxtuple\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"\r\n"
"template <$for j, [[class Generator$j]]>\r\n"
"class CartesianProductHolder$i {\r\n"
" public:\r\n"
"CartesianProductHolder$i($for j, [[const Generator$j& g$j]])\r\n"
"      : $for j, [[g$(j)_(g$j)]] {}\r\n"
"  template <$for j, [[typename T$j]]>\r\n"
"  operator ParamGenerator< ::testing::tuple<$for j, [[T$j]]> >() const {\r\n"
"    return ParamGenerator< ::testing::tuple<$for j, [[T$j]]> >(\r\n"
"        new CartesianProductGenerator$i<$for j, [[T$j]]>(\r\n"
"$for j,[[\r\n"
"\r\n"
"        static_cast<ParamGenerator<T$j> >(g$(j)_)\r\n"
"]]));\r\n"
"  }\r\n"
"\r\n"
" private:\r\n"
"  // No implementation - assignment is unsupported.\r\n"
"  void operator=(const CartesianProductHolder$i& other);\r\n"
"\r\n"
"\r\n"
"$for j [[\r\n"
"  const Generator$j g$(j)_;\r\n"
"\r\n"
"]]\r\n"
"};  // class CartesianProductHolder$i\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"# endif  // GTEST_HAS_COMBINE\r\n"
"\r\n"
"}  // namespace internal\r\n"
"}  // namespace testing\r\n"
"\r\n"
"#endif  //  GTEST_HAS_PARAM_TEST\r\n"
"\r\n"
"#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\r\n";

const char* gtestparamutilgenerated_h_pump = (const char*) temp_binary_data_36;

//================== gtest-tuple.h.pump ==================
static const unsigned char temp_binary_data_37[] =
"$$ -*- mode: c++; -*-\r\n"
"$var n = 10  $$ Maximum number of tuple fields we want to support.\r\n"
"$$ This meta comment fixes auto-indentation in Emacs. }}\r\n"
"// Copyright 2009 Google Inc.\r\n"
"// All Rights Reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: wan@google.com (Zhanyong Wan)\r\n"
"\r\n"
"// Implements a subset of TR1 tuple needed by Google Test and Google Mock.\r\n"
"\r\n"
"#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_\r\n"
"#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_\r\n"
"\r\n"
"#include <utility>  // For ::std::pair.\r\n"
"\r\n"
"// The compiler used in Symbian has a bug that prevents us from declaring the\r\n"
"// tuple template as a friend (it complains that tuple is redefined).  This\r\n"
"// hack bypasses the bug by declaring the members that should otherwise be\r\n"
"// private as public.\r\n"
"// Sun Studio versions < 12 also have the above bug.\r\n"
"#if defined(__SYMBIAN32__) || (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x590)\r\n"
"# define GTEST_DECLARE_TUPLE_AS_FRIEND_ public:\r\n"
"#else\r\n"
"# define GTEST_DECLARE_TUPLE_AS_FRIEND_ \\\r\n"
"    template <GTEST_$(n)_TYPENAMES_(U)> friend class tuple; \\\r\n"
"   private:\r\n"
"#endif\r\n"
"\r\n"
"// Visual Studio 2010, 2012, and 2013 define symbols in std::tr1 that conflict\r\n"
"// with our own definitions. Therefore using our own tuple does not work on\r\n"
"// those compilers.\r\n"
"#if defined(_MSC_VER) && _MSC_VER >= 1600  /* 1600 is Visual Studio 2010 */\r\n"
"# error \"gtest's tuple doesn't compile on Visual Studio 2010 or later. \\\r\n"
"GTEST_USE_OWN_TR1_TUPLE must be set to 0 on those compilers.\"\r\n"
"#endif\r\n"
"\r\n"
"\r\n"
"$range i 0..n-1\r\n"
"$range j 0..n\r\n"
"$range k 1..n\r\n"
"// GTEST_n_TUPLE_(T) is the type of an n-tuple.\r\n"
"#define GTEST_0_TUPLE_(T) tuple<>\r\n"
"\r\n"
"$for k [[\r\n"
"$range m 0..k-1\r\n"
"$range m2 k..n-1\r\n"
"#define GTEST_$(k)_TUPLE_(T) tuple<$for m, [[T##$m]]$for m2 [[, void]]>\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// GTEST_n_TYPENAMES_(T) declares a list of n typenames.\r\n"
"\r\n"
"$for j [[\r\n"
"$range m 0..j-1\r\n"
"#define GTEST_$(j)_TYPENAMES_(T) $for m, [[typename T##$m]]\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// In theory, defining stuff in the ::std namespace is undefined\r\n"
"// behavior.  We can do this as we are playing the role of a standard\r\n"
"// library vendor.\r\n"
"namespace std {\r\n"
"namespace tr1 {\r\n"
"\r\n"
"template <$for i, [[typename T$i = void]]>\r\n"
"class tuple;\r\n"
"\r\n"
"// Anything in namespace gtest_internal is Google Test's INTERNAL\r\n"
"// IMPLEMENTATION DETAIL and MUST NOT BE USED DIRECTLY in user code.\r\n"
"namespace gtest_internal {\r\n"
"\r\n"
"// ByRef<T>::type is T if T is a reference; otherwise it's const T&.\r\n"
"template <typename T>\r\n"
"struct ByRef { typedef const T& type; };  // NOLINT\r\n"
"template <typename T>\r\n"
"struct ByRef<T&> { typedef T& type; };  // NOLINT\r\n"
"\r\n"
"// A handy wrapper for ByRef.\r\n"
"#define GTEST_BY_REF_(T) typename ::std::tr1::gtest_internal::ByRef<T>::type\r\n"
"\r\n"
"// AddRef<T>::type is T if T is a reference; otherwise it's T&.  This\r\n"
"// is the same as tr1::add_reference<T>::type.\r\n"
"template <typename T>\r\n"
"struct AddRef { typedef T& type; };  // NOLINT\r\n"
"template <typename T>\r\n"
"struct AddRef<T&> { typedef T& type; };  // NOLINT\r\n"
"\r\n"
"// A handy wrapper for AddRef.\r\n"
"#define GTEST_ADD_REF_(T) typename ::std::tr1::gtest_internal::AddRef<T>::type\r\n"
"\r\n"
"// A helper for implementing get<k>().\r\n"
"template <int k> class Get;\r\n"
"\r\n"
"// A helper for implementing tuple_element<k, T>.  kIndexValid is true\r\n"
"// iff k < the number of fields in tuple type T.\r\n"
"template <bool kIndexValid, int kIndex, class Tuple>\r\n"
"struct TupleElement;\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"template <GTEST_$(n)_TYPENAMES_(T)>\r\n"
"struct TupleElement<true, $i, GTEST_$(n)_TUPLE_(T) > {\r\n"
"  typedef T$i type;\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"}  // namespace gtest_internal\r\n"
"\r\n"
"template <>\r\n"
"class tuple<> {\r\n"
" public:\r\n"
"  tuple() {}\r\n"
"  tuple(const tuple& /* t */)  {}\r\n"
"  tuple& operator=(const tuple& /* t */) { return *this; }\r\n"
"};\r\n"
"\r\n"
"\r\n"
"$for k [[\r\n"
"$range m 0..k-1\r\n"
"template <GTEST_$(k)_TYPENAMES_(T)>\r\n"
"class $if k < n [[GTEST_$(k)_TUPLE_(T)]] $else [[tuple]] {\r\n"
" public:\r\n"
"  template <int k> friend class gtest_internal::Get;\r\n"
"\r\n"
"  tuple() : $for m, [[f$(m)_()]] {}\r\n"
"\r\n"
"  explicit tuple($for m, [[GTEST_BY_REF_(T$m) f$m]]) : [[]]\r\n"
"$for m, [[f$(m)_(f$m)]] {}\r\n"
"\r\n"
"  tuple(const tuple& t) : $for m, [[f$(m)_(t.f$(m)_)]] {}\r\n"
"\r\n"
"  template <GTEST_$(k)_TYPENAMES_(U)>\r\n"
"  tuple(const GTEST_$(k)_TUPLE_(U)& t) : $for m, [[f$(m)_(t.f$(m)_)]] {}\r\n"
"\r\n"
"$if k == 2 [[\r\n"
"  template <typename U0, typename U1>\r\n"
"  tuple(const ::std::pair<U0, U1>& p) : f0_(p.first), f1_(p.second) {}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"  tuple& operator=(const tuple& t) { return CopyFrom(t); }\r\n"
"\r\n"
"  template <GTEST_$(k)_TYPENAMES_(U)>\r\n"
"  tuple& operator=(const GTEST_$(k)_TUPLE_(U)& t) {\r\n"
"    return CopyFrom(t);\r\n"
"  }\r\n"
"\r\n"
"$if k == 2 [[\r\n"
"  template <typename U0, typename U1>\r\n"
"  tuple& operator=(const ::std::pair<U0, U1>& p) {\r\n"
"    f0_ = p.first;\r\n"
"    f1_ = p.second;\r\n"
"    return *this;\r\n"
"  }\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"  GTEST_DECLARE_TUPLE_AS_FRIEND_\r\n"
"\r\n"
"  template <GTEST_$(k)_TYPENAMES_(U)>\r\n"
"  tuple& CopyFrom(const GTEST_$(k)_TUPLE_(U)& t) {\r\n"
"\r\n"
"$for m [[\r\n"
"    f$(m)_ = t.f$(m)_;\r\n"
"\r\n"
"]]\r\n"
"    return *this;\r\n"
"  }\r\n"
"\r\n"
"\r\n"
"$for m [[\r\n"
"  T$m f$(m)_;\r\n"
"\r\n"
"]]\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"// 6.1.3.2 Tuple creation functions.\r\n"
"\r\n"
"// Known limitations: we don't support passing an\r\n"
"// std::tr1::reference_wrapper<T> to make_tuple().  And we don't\r\n"
"// implement tie().\r\n"
"\r\n"
"inline tuple<> make_tuple() { return tuple<>(); }\r\n"
"\r\n"
"$for k [[\r\n"
"$range m 0..k-1\r\n"
"\r\n"
"template <GTEST_$(k)_TYPENAMES_(T)>\r\n"
"inline GTEST_$(k)_TUPLE_(T) make_tuple($for m, [[const T$m& f$m]]) {\r\n"
"  return GTEST_$(k)_TUPLE_(T)($for m, [[f$m]]);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// 6.1.3.3 Tuple helper classes.\r\n"
"\r\n"
"template <typename Tuple> struct tuple_size;\r\n"
"\r\n"
"\r\n"
"$for j [[\r\n"
"template <GTEST_$(j)_TYPENAMES_(T)>\r\n"
"struct tuple_size<GTEST_$(j)_TUPLE_(T) > {\r\n"
"  static const int value = $j;\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"template <int k, class Tuple>\r\n"
"struct tuple_element {\r\n"
"  typedef typename gtest_internal::TupleElement<\r\n"
"      k < (tuple_size<Tuple>::value), k, Tuple>::type type;\r\n"
"};\r\n"
"\r\n"
"#define GTEST_TUPLE_ELEMENT_(k, Tuple) typename tuple_element<k, Tuple >::type\r\n"
"\r\n"
"// 6.1.3.4 Element access.\r\n"
"\r\n"
"namespace gtest_internal {\r\n"
"\r\n"
"\r\n"
"$for i [[\r\n"
"template <>\r\n"
"class Get<$i> {\r\n"
" public:\r\n"
"  template <class Tuple>\r\n"
"  static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_($i, Tuple))\r\n"
"  Field(Tuple& t) { return t.f$(i)_; }  // NOLINT\r\n"
"\r\n"
"  template <class Tuple>\r\n"
"  static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_($i, Tuple))\r\n"
"  ConstField(const Tuple& t) { return t.f$(i)_; }\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"}  // namespace gtest_internal\r\n"
"\r\n"
"template <int k, GTEST_$(n)_TYPENAMES_(T)>\r\n"
"GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(k, GTEST_$(n)_TUPLE_(T)))\r\n"
"get(GTEST_$(n)_TUPLE_(T)& t) {\r\n"
"  return gtest_internal::Get<k>::Field(t);\r\n"
"}\r\n"
"\r\n"
"template <int k, GTEST_$(n)_TYPENAMES_(T)>\r\n"
"GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(k,  GTEST_$(n)_TUPLE_(T)))\r\n"
"get(const GTEST_$(n)_TUPLE_(T)& t) {\r\n"
"  return gtest_internal::Get<k>::ConstField(t);\r\n"
"}\r\n"
"\r\n"
"// 6.1.3.5 Relational operators\r\n"
"\r\n"
"// We only implement == and !=, as we don't have a need for the rest yet.\r\n"
"\r\n"
"namespace gtest_internal {\r\n"
"\r\n"
"// SameSizeTuplePrefixComparator<k, k>::Eq(t1, t2) returns true if the\r\n"
"// first k fields of t1 equals the first k fields of t2.\r\n"
"// SameSizeTuplePrefixComparator(k1, k2) would be a compiler error if\r\n"
"// k1 != k2.\r\n"
"template <int kSize1, int kSize2>\r\n"
"struct SameSizeTuplePrefixComparator;\r\n"
"\r\n"
"template <>\r\n"
"struct SameSizeTuplePrefixComparator<0, 0> {\r\n"
"  template <class Tuple1, class Tuple2>\r\n"
"  static bool Eq(const Tuple1& /* t1 */, const Tuple2& /* t2 */) {\r\n"
"    return true;\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"template <int k>\r\n"
"struct SameSizeTuplePrefixComparator<k, k> {\r\n"
"  template <class Tuple1, class Tuple2>\r\n"
"  static bool Eq(const Tuple1& t1, const Tuple2& t2) {\r\n"
"    return SameSizeTuplePrefixComparator<k - 1, k - 1>::Eq(t1, t2) &&\r\n"
"        ::std::tr1::get<k - 1>(t1) == ::std::tr1::get<k - 1>(t2);\r\n"
"  }\r\n"
"};\r\n"
"\r\n"
"}  // namespace gtest_internal\r\n"
"\r\n"
"template <GTEST_$(n)_TYPENAMES_(T), GTEST_$(n)_TYPENAMES_(U)>\r\n"
"inline bool operator==(const GTEST_$(n)_TUPLE_(T)& t,\r\n"
"                       const GTEST_$(n)_TUPLE_(U)& u) {\r\n"
"  return gtest_internal::SameSizeTuplePrefixComparator<\r\n"
"      tuple_size<GTEST_$(n)_TUPLE_(T) >::value,\r\n"
"      tuple_size<GTEST_$(n)_TUPLE_(U) >::value>::Eq(t, u);\r\n"
"}\r\n"
"\r\n"
"template <GTEST_$(n)_TYPENAMES_(T), GTEST_$(n)_TYPENAMES_(U)>\r\n"
"inline bool operator!=(const GTEST_$(n)_TUPLE_(T)& t,\r\n"
"                       const GTEST_$(n)_TUPLE_(U)& u) { return !(t == u); }\r\n"
"\r\n"
"// 6.1.4 Pairs.\r\n"
"// Unimplemented.\r\n"
"\r\n"
"}  // namespace tr1\r\n"
"}  // namespace std\r\n"
"\r\n"
"\r\n"
"$for j [[\r\n"
"#undef GTEST_$(j)_TUPLE_\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"$for j [[\r\n"
"#undef GTEST_$(j)_TYPENAMES_\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"#undef GTEST_DECLARE_TUPLE_AS_FRIEND_\r\n"
"#undef GTEST_BY_REF_\r\n"
"#undef GTEST_ADD_REF_\r\n"
"#undef GTEST_TUPLE_ELEMENT_\r\n"
"\r\n"
"#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_\r\n";

const char* gtesttuple_h_pump = (const char*) temp_binary_data_37;

//================== gtest-type-util.h.pump ==================
static const unsigned char temp_binary_data_38[] =
"$$ -*- mode: c++; -*-\r\n"
"$var n = 50  $$ Maximum length of type lists we want to support.\r\n"
"// Copyright 2008 Google Inc.\r\n"
"// All Rights Reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Author: wan@google.com (Zhanyong Wan)\r\n"
"\r\n"
"// Type utilities needed for implementing typed and type-parameterized\r\n"
"// tests.  This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\r\n"
"//\r\n"
"// Currently we support at most $n types in a list, and at most $n\r\n"
"// type-parameterized tests in one type-parameterized test case.\r\n"
"// Please contact googletestframework@googlegroups.com if you need\r\n"
"// more.\r\n"
"\r\n"
"#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\r\n"
"#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\r\n"
"\r\n"
"#include \"gtest/internal/gtest-port.h\"\r\n"
"\r\n"
"// #ifdef __GNUC__ is too general here.  It is possible to use gcc without using\r\n"
"// libstdc++ (which is where cxxabi.h comes from).\r\n"
"# if GTEST_HAS_CXXABI_H_\r\n"
"#  include <cxxabi.h>\r\n"
"# elif defined(__HP_aCC)\r\n"
"#  include <acxx_demangle.h>\r\n"
"# endif  // GTEST_HASH_CXXABI_H_\r\n"
"\r\n"
"namespace testing {\r\n"
"namespace internal {\r\n"
"\r\n"
"// GetTypeName<T>() returns a human-readable name of type T.\r\n"
"// NB: This function is also used in Google Mock, so don't move it inside of\r\n"
"// the typed-test-only section below.\r\n"
"template <typename T>\r\n"
"std::string GetTypeName() {\r\n"
"# if GTEST_HAS_RTTI\r\n"
"\r\n"
"  const char* const name = typeid(T).name();\r\n"
"#  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)\r\n"
"  int status = 0;\r\n"
"  // gcc's implementation of typeid(T).name() mangles the type name,\r\n"
"  // so we have to demangle it.\r\n"
"#   if GTEST_HAS_CXXABI_H_\r\n"
"  using abi::__cxa_demangle;\r\n"
"#   endif  // GTEST_HAS_CXXABI_H_\r\n"
"  char* const readable_name = __cxa_demangle(name, 0, 0, &status);\r\n"
"  const std::string name_str(status == 0 ? readable_name : name);\r\n"
"  free(readable_name);\r\n"
"  return name_str;\r\n"
"#  else\r\n"
"  return name;\r\n"
"#  endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC\r\n"
"\r\n"
"# else\r\n"
"\r\n"
"  return \"<type>\";\r\n"
"\r\n"
"# endif  // GTEST_HAS_RTTI\r\n"
"}\r\n"
"\r\n"
"#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\r\n"
"\r\n"
"// AssertyTypeEq<T1, T2>::type is defined iff T1 and T2 are the same\r\n"
"// type.  This can be used as a compile-time assertion to ensure that\r\n"
"// two types are equal.\r\n"
"\r\n"
"template <typename T1, typename T2>\r\n"
"struct AssertTypeEq;\r\n"
"\r\n"
"template <typename T>\r\n"
"struct AssertTypeEq<T, T> {\r\n"
"  typedef bool type;\r\n"
"};\r\n"
"\r\n"
"// A unique type used as the default value for the arguments of class\r\n"
"// template Types.  This allows us to simulate variadic templates\r\n"
"// (e.g. Types<int>, Type<int, double>, and etc), which C++ doesn't\r\n"
"// support directly.\r\n"
"struct None {};\r\n"
"\r\n"
"// The following family of struct and struct templates are used to\r\n"
"// represent type lists.  In particular, TypesN<T1, T2, ..., TN>\r\n"
"// represents a type list with N types (T1, T2, ..., and TN) in it.\r\n"
"// Except for Types0, every struct in the family has two member types:\r\n"
"// Head for the first type in the list, and Tail for the rest of the\r\n"
"// list.\r\n"
"\r\n"
"// The empty type list.\r\n"
"struct Types0 {};\r\n"
"\r\n"
"// Type lists of length 1, 2, 3, and so on.\r\n"
"\r\n"
"template <typename T1>\r\n"
"struct Types1 {\r\n"
"  typedef T1 Head;\r\n"
"  typedef Types0 Tail;\r\n"
"};\r\n"
"\r\n"
"$range i 2..n\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$range k 2..i\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"struct Types$i {\r\n"
"  typedef T1 Head;\r\n"
"  typedef Types$(i-1)<$for k, [[T$k]]> Tail;\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"}  // namespace internal\r\n"
"\r\n"
"// We don't want to require the users to write TypesN<...> directly,\r\n"
"// as that would require them to count the length.  Types<...> is much\r\n"
"// easier to write, but generates horrible messages when there is a\r\n"
"// compiler error, as gcc insists on printing out each template\r\n"
"// argument, even if it has the default value (this means Types<int>\r\n"
"// will appear as Types<int, None, None, ..., None> in the compiler\r\n"
"// errors).\r\n"
"//\r\n"
"// Our solution is to combine the best part of the two approaches: a\r\n"
"// user would write Types<T1, ..., TN>, and Google Test will translate\r\n"
"// that to TypesN<T1, ..., TN> internally to make error messages\r\n"
"// readable.  The translation is done by the 'type' member of the\r\n"
"// Types template.\r\n"
"\r\n"
"$range i 1..n\r\n"
"template <$for i, [[typename T$i = internal::None]]>\r\n"
"struct Types {\r\n"
"  typedef internal::Types$n<$for i, [[T$i]]> type;\r\n"
"};\r\n"
"\r\n"
"template <>\r\n"
"struct Types<$for i, [[internal::None]]> {\r\n"
"  typedef internal::Types0 type;\r\n"
"};\r\n"
"\r\n"
"$range i 1..n-1\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$range k i+1..n\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"struct Types<$for j, [[T$j]]$for k[[, internal::None]]> {\r\n"
"  typedef internal::Types$i<$for j, [[T$j]]> type;\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"namespace internal {\r\n"
"\r\n"
"# define GTEST_TEMPLATE_ template <typename T> class\r\n"
"\r\n"
"// The template \"selector\" struct TemplateSel<Tmpl> is used to\r\n"
"// represent Tmpl, which must be a class template with one type\r\n"
"// parameter, as a type.  TemplateSel<Tmpl>::Bind<T>::type is defined\r\n"
"// as the type Tmpl<T>.  This allows us to actually instantiate the\r\n"
"// template \"selected\" by TemplateSel<Tmpl>.\r\n"
"//\r\n"
"// This trick is necessary for simulating typedef for class templates,\r\n"
"// which C++ doesn't support directly.\r\n"
"template <GTEST_TEMPLATE_ Tmpl>\r\n"
"struct TemplateSel {\r\n"
"  template <typename T>\r\n"
"  struct Bind {\r\n"
"    typedef Tmpl<T> type;\r\n"
"  };\r\n"
"};\r\n"
"\r\n"
"# define GTEST_BIND_(TmplSel, T) \\\r\n"
"  TmplSel::template Bind<T>::type\r\n"
"\r\n"
"// A unique struct template used as the default value for the\r\n"
"// arguments of class template Templates.  This allows us to simulate\r\n"
"// variadic templates (e.g. Templates<int>, Templates<int, double>,\r\n"
"// and etc), which C++ doesn't support directly.\r\n"
"template <typename T>\r\n"
"struct NoneT {};\r\n"
"\r\n"
"// The following family of struct and struct templates are used to\r\n"
"// represent template lists.  In particular, TemplatesN<T1, T2, ...,\r\n"
"// TN> represents a list of N templates (T1, T2, ..., and TN).  Except\r\n"
"// for Templates0, every struct in the family has two member types:\r\n"
"// Head for the selector of the first template in the list, and Tail\r\n"
"// for the rest of the list.\r\n"
"\r\n"
"// The empty template list.\r\n"
"struct Templates0 {};\r\n"
"\r\n"
"// Template lists of length 1, 2, 3, and so on.\r\n"
"\r\n"
"template <GTEST_TEMPLATE_ T1>\r\n"
"struct Templates1 {\r\n"
"  typedef TemplateSel<T1> Head;\r\n"
"  typedef Templates0 Tail;\r\n"
"};\r\n"
"\r\n"
"$range i 2..n\r\n"
"\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$range k 2..i\r\n"
"template <$for j, [[GTEST_TEMPLATE_ T$j]]>\r\n"
"struct Templates$i {\r\n"
"  typedef TemplateSel<T1> Head;\r\n"
"  typedef Templates$(i-1)<$for k, [[T$k]]> Tail;\r\n"
"};\r\n"
"\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// We don't want to require the users to write TemplatesN<...> directly,\r\n"
"// as that would require them to count the length.  Templates<...> is much\r\n"
"// easier to write, but generates horrible messages when there is a\r\n"
"// compiler error, as gcc insists on printing out each template\r\n"
"// argument, even if it has the default value (this means Templates<list>\r\n"
"// will appear as Templates<list, NoneT, NoneT, ..., NoneT> in the compiler\r\n"
"// errors).\r\n"
"//\r\n"
"// Our solution is to combine the best part of the two approaches: a\r\n"
"// user would write Templates<T1, ..., TN>, and Google Test will translate\r\n"
"// that to TemplatesN<T1, ..., TN> internally to make error messages\r\n"
"// readable.  The translation is done by the 'type' member of the\r\n"
"// Templates template.\r\n"
"\r\n"
"$range i 1..n\r\n"
"template <$for i, [[GTEST_TEMPLATE_ T$i = NoneT]]>\r\n"
"struct Templates {\r\n"
"  typedef Templates$n<$for i, [[T$i]]> type;\r\n"
"};\r\n"
"\r\n"
"template <>\r\n"
"struct Templates<$for i, [[NoneT]]> {\r\n"
"  typedef Templates0 type;\r\n"
"};\r\n"
"\r\n"
"$range i 1..n-1\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"$range k i+1..n\r\n"
"template <$for j, [[GTEST_TEMPLATE_ T$j]]>\r\n"
"struct Templates<$for j, [[T$j]]$for k[[, NoneT]]> {\r\n"
"  typedef Templates$i<$for j, [[T$j]]> type;\r\n"
"};\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// The TypeList template makes it possible to use either a single type\r\n"
"// or a Types<...> list in TYPED_TEST_CASE() and\r\n"
"// INSTANTIATE_TYPED_TEST_CASE_P().\r\n"
"\r\n"
"template <typename T>\r\n"
"struct TypeList {\r\n"
"  typedef Types1<T> type;\r\n"
"};\r\n"
"\r\n"
"\r\n"
"$range i 1..n\r\n"
"template <$for i, [[typename T$i]]>\r\n"
"struct TypeList<Types<$for i, [[T$i]]> > {\r\n"
"  typedef typename Types<$for i, [[T$i]]>::type type;\r\n"
"};\r\n"
"\r\n"
"#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\r\n"
"\r\n"
"}  // namespace internal\r\n"
"}  // namespace testing\r\n"
"\r\n"
"#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\r\n";

const char* gtesttypeutil_h_pump = (const char*) temp_binary_data_38;

//================== gtest-param-test.h.pump ==================
static const unsigned char temp_binary_data_39[] =
"$$ -*- mode: c++; -*-\r\n"
"$var n = 50  $$ Maximum length of Values arguments we want to support.\r\n"
"$var maxtuple = 10  $$ Maximum number of Combine arguments we want to support.\r\n"
"// Copyright 2008, Google Inc.\r\n"
"// All rights reserved.\r\n"
"//\r\n"
"// Redistribution and use in source and binary forms, with or without\r\n"
"// modification, are permitted provided that the following conditions are\r\n"
"// met:\r\n"
"//\r\n"
"//     * Redistributions of source code must retain the above copyright\r\n"
"// notice, this list of conditions and the following disclaimer.\r\n"
"//     * Redistributions in binary form must reproduce the above\r\n"
"// copyright notice, this list of conditions and the following disclaimer\r\n"
"// in the documentation and/or other materials provided with the\r\n"
"// distribution.\r\n"
"//     * Neither the name of Google Inc. nor the names of its\r\n"
"// contributors may be used to endorse or promote products derived from\r\n"
"// this software without specific prior written permission.\r\n"
"//\r\n"
"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n"
"// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n"
"// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n"
"// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n"
"// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n"
"// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n"
"// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n"
"// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n"
"// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n"
"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n"
"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n"
"//\r\n"
"// Authors: vladl@google.com (Vlad Losev)\r\n"
"//\r\n"
"// Macros and functions for implementing parameterized tests\r\n"
"// in Google C++ Testing Framework (Google Test)\r\n"
"//\r\n"
"// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\r\n"
"//\r\n"
"#ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\r\n"
"#define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\r\n"
"\r\n"
"\r\n"
"// Value-parameterized tests allow you to test your code with different\r\n"
"// parameters without writing multiple copies of the same test.\r\n"
"//\r\n"
"// Here is how you use value-parameterized tests:\r\n"
"\r\n"
"#if 0\r\n"
"\r\n"
"// To write value-parameterized tests, first you should define a fixture\r\n"
"// class. It is usually derived from testing::TestWithParam<T> (see below for\r\n"
"// another inheritance scheme that's sometimes useful in more complicated\r\n"
"// class hierarchies), where the type of your parameter values.\r\n"
"// TestWithParam<T> is itself derived from testing::Test. T can be any\r\n"
"// copyable type. If it's a raw pointer, you are responsible for managing the\r\n"
"// lifespan of the pointed values.\r\n"
"\r\n"
"class FooTest : public ::testing::TestWithParam<const char*> {\r\n"
"  // You can implement all the usual class fixture members here.\r\n"
"};\r\n"
"\r\n"
"// Then, use the TEST_P macro to define as many parameterized tests\r\n"
"// for this fixture as you want. The _P suffix is for \"parameterized\"\r\n"
"// or \"pattern\", whichever you prefer to think.\r\n"
"\r\n"
"TEST_P(FooTest, DoesBlah) {\r\n"
"  // Inside a test, access the test parameter with the GetParam() method\r\n"
"  // of the TestWithParam<T> class:\r\n"
"  EXPECT_TRUE(foo.Blah(GetParam()));\r\n"
"  ...\r\n"
"}\r\n"
"\r\n"
"TEST_P(FooTest, HasBlahBlah) {\r\n"
"  ...\r\n"
"}\r\n"
"\r\n"
"// Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test\r\n"
"// case with any set of parameters you want. Google Test defines a number\r\n"
"// of functions for generating test parameters. They return what we call\r\n"
"// (surprise!) parameter generators. Here is a  summary of them, which\r\n"
"// are all in the testing namespace:\r\n"
"//\r\n"
"//\r\n"
"//  Range(begin, end [, step]) - Yields values {begin, begin+step,\r\n"
"//                               begin+step+step, ...}. The values do not\r\n"
"//                               include end. step defaults to 1.\r\n"
"//  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.\r\n"
"//  ValuesIn(container)        - Yields values from a C-style array, an STL\r\n"
"//  ValuesIn(begin,end)          container, or an iterator range [begin, end).\r\n"
"//  Bool()                     - Yields sequence {false, true}.\r\n"
"//  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product\r\n"
"//                               for the math savvy) of the values generated\r\n"
"//                               by the N generators.\r\n"
"//\r\n"
"// For more details, see comments at the definitions of these functions below\r\n"
"// in this file.\r\n"
"//\r\n"
"// The following statement will instantiate tests from the FooTest test case\r\n"
"// each with parameter values \"meeny\", \"miny\", and \"moe\".\r\n"
"\r\n"
"INSTANTIATE_TEST_CASE_P(InstantiationName,\r\n"
"                        FooTest,\r\n"
"                        Values(\"meeny\", \"miny\", \"moe\"));\r\n"
"\r\n"
"// To distinguish different instances of the pattern, (yes, you\r\n"
"// can instantiate it more then once) the first argument to the\r\n"
"// INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the\r\n"
"// actual test case name. Remember to pick unique prefixes for different\r\n"
"// instantiations. The tests from the instantiation above will have\r\n"
"// these names:\r\n"
"//\r\n"
"//    * InstantiationName/FooTest.DoesBlah/0 for \"meeny\"\r\n"
"//    * InstantiationName/FooTest.DoesBlah/1 for \"miny\"\r\n"
"//    * InstantiationName/FooTest.DoesBlah/2 for \"moe\"\r\n"
"//    * InstantiationName/FooTest.HasBlahBlah/0 for \"meeny\"\r\n"
"//    * InstantiationName/FooTest.HasBlahBlah/1 for \"miny\"\r\n"
"//    * InstantiationName/FooTest.HasBlahBlah/2 for \"moe\"\r\n"
"//\r\n"
"// You can use these names in --gtest_filter.\r\n"
"//\r\n"
"// This statement will instantiate all tests from FooTest again, each\r\n"
"// with parameter values \"cat\" and \"dog\":\r\n"
"\r\n"
"const char* pets[] = {\"cat\", \"dog\"};\r\n"
"INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));\r\n"
"\r\n"
"// The tests from the instantiation above will have these names:\r\n"
"//\r\n"
"//    * AnotherInstantiationName/FooTest.DoesBlah/0 for \"cat\"\r\n"
"//    * AnotherInstantiationName/FooTest.DoesBlah/1 for \"dog\"\r\n"
"//    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for \"cat\"\r\n"
"//    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for \"dog\"\r\n"
"//\r\n"
"// Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests\r\n"
"// in the given test case, whether their definitions come before or\r\n"
"// AFTER the INSTANTIATE_TEST_CASE_P statement.\r\n"
"//\r\n"
"// Please also note that generator expressions (including parameters to the\r\n"
"// generators) are evaluated in InitGoogleTest(), after main() has started.\r\n"
"// This allows the user on one hand, to adjust generator parameters in order\r\n"
"// to dynamically determine a set of tests to run and on the other hand,\r\n"
"// give the user a chance to inspect the generated tests with Google Test\r\n"
"// reflection API before RUN_ALL_TESTS() is executed.\r\n"
"//\r\n"
"// You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc\r\n"
"// for more examples.\r\n"
"//\r\n"
"// In the future, we plan to publish the API for defining new parameter\r\n"
"// generators. But for now this interface remains part of the internal\r\n"
"// implementation and is subject to change.\r\n"
"//\r\n"
"//\r\n"
"// A parameterized test fixture must be derived from testing::Test and from\r\n"
"// testing::WithParamInterface<T>, where T is the type of the parameter\r\n"
"// values. Inheriting from TestWithParam<T> satisfies that requirement because\r\n"
"// TestWithParam<T> inherits from both Test and WithParamInterface. In more\r\n"
"// complicated hierarchies, however, it is occasionally useful to inherit\r\n"
"// separately from Test and WithParamInterface. For example:\r\n"
"\r\n"
"class BaseTest : public ::testing::Test {\r\n"
"  // You can inherit all the usual members for a non-parameterized test\r\n"
"  // fixture here.\r\n"
"};\r\n"
"\r\n"
"class DerivedTest : public BaseTest, public ::testing::WithParamInterface<int> {\r\n"
"  // The usual test fixture members go here too.\r\n"
"};\r\n"
"\r\n"
"TEST_F(BaseTest, HasFoo) {\r\n"
"  // This is an ordinary non-parameterized test.\r\n"
"}\r\n"
"\r\n"
"TEST_P(DerivedTest, DoesBlah) {\r\n"
"  // GetParam works just the same here as if you inherit from TestWithParam.\r\n"
"  EXPECT_TRUE(foo.Blah(GetParam()));\r\n"
"}\r\n"
"\r\n"
"#endif  // 0\r\n"
"\r\n"
"#include \"gtest/internal/gtest-port.h\"\r\n"
"\r\n"
"#if !GTEST_OS_SYMBIAN\r\n"
"# include <utility>\r\n"
"#endif\r\n"
"\r\n"
"// scripts/fuse_gtest.py depends on gtest's own header being #included\r\n"
"// *unconditionally*.  Therefore these #includes cannot be moved\r\n"
"// inside #if GTEST_HAS_PARAM_TEST.\r\n"
"#include \"gtest/internal/gtest-internal.h\"\r\n"
"#include \"gtest/internal/gtest-param-util.h\"\r\n"
"#include \"gtest/internal/gtest-param-util-generated.h\"\r\n"
"\r\n"
"#if GTEST_HAS_PARAM_TEST\r\n"
"\r\n"
"namespace testing {\r\n"
"\r\n"
"// Functions producing parameter generators.\r\n"
"//\r\n"
"// Google Test uses these generators to produce parameters for value-\r\n"
"// parameterized tests. When a parameterized test case is instantiated\r\n"
"// with a particular generator, Google Test creates and runs tests\r\n"
"// for each element in the sequence produced by the generator.\r\n"
"//\r\n"
"// In the following sample, tests from test case FooTest are instantiated\r\n"
"// each three times with parameter values 3, 5, and 8:\r\n"
"//\r\n"
"// class FooTest : public TestWithParam<int> { ... };\r\n"
"//\r\n"
"// TEST_P(FooTest, TestThis) {\r\n"
"// }\r\n"
"// TEST_P(FooTest, TestThat) {\r\n"
"// }\r\n"
"// INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));\r\n"
"//\r\n"
"\r\n"
"// Range() returns generators providing sequences of values in a range.\r\n"
"//\r\n"
"// Synopsis:\r\n"
"// Range(start, end)\r\n"
"//   - returns a generator producing a sequence of values {start, start+1,\r\n"
"//     start+2, ..., }.\r\n"
"// Range(start, end, step)\r\n"
"//   - returns a generator producing a sequence of values {start, start+step,\r\n"
"//     start+step+step, ..., }.\r\n"
"// Notes:\r\n"
"//   * The generated sequences never include end. For example, Range(1, 5)\r\n"
"//     returns a generator producing a sequence {1, 2, 3, 4}. Range(1, 9, 2)\r\n"
"//     returns a generator producing {1, 3, 5, 7}.\r\n"
"//   * start and end must have the same type. That type may be any integral or\r\n"
"//     floating-point type or a user defined type satisfying these conditions:\r\n"
"//     * It must be assignable (have operator=() defined).\r\n"
"//     * It must have operator+() (operator+(int-compatible type) for\r\n"
"//       two-operand version).\r\n"
"//     * It must have operator<() defined.\r\n"
"//     Elements in the resulting sequences will also have that type.\r\n"
"//   * Condition start < end must be satisfied in order for resulting sequences\r\n"
"//     to contain any elements.\r\n"
"//\r\n"
"template <typename T, typename IncrementT>\r\n"
"internal::ParamGenerator<T> Range(T start, T end, IncrementT step) {\r\n"
"  return internal::ParamGenerator<T>(\r\n"
"      new internal::RangeGenerator<T, IncrementT>(start, end, step));\r\n"
"}\r\n"
"\r\n"
"template <typename T>\r\n"
"internal::ParamGenerator<T> Range(T start, T end) {\r\n"
"  return Range(start, end, 1);\r\n"
"}\r\n"
"\r\n"
"// ValuesIn() function allows generation of tests with parameters coming from\r\n"
"// a container.\r\n"
"//\r\n"
"// Synopsis:\r\n"
"// ValuesIn(const T (&array)[N])\r\n"
"//   - returns a generator producing sequences with elements from\r\n"
"//     a C-style array.\r\n"
"// ValuesIn(const Container& container)\r\n"
"//   - returns a generator producing sequences with elements from\r\n"
"//     an STL-style container.\r\n"
"// ValuesIn(Iterator begin, Iterator end)\r\n"
"//   - returns a generator producing sequences with elements from\r\n"
"//     a range [begin, end) defined by a pair of STL-style iterators. These\r\n"
"//     iterators can also be plain C pointers.\r\n"
"//\r\n"
"// Please note that ValuesIn copies the values from the containers\r\n"
"// passed in and keeps them to generate tests in RUN_ALL_TESTS().\r\n"
"//\r\n"
"// Examples:\r\n"
"//\r\n"
"// This instantiates tests from test case StringTest\r\n"
"// each with C-string values of \"foo\", \"bar\", and \"baz\":\r\n"
"//\r\n"
"// const char* strings[] = {\"foo\", \"bar\", \"baz\"};\r\n"
"// INSTANTIATE_TEST_CASE_P(StringSequence, SrtingTest, ValuesIn(strings));\r\n"
"//\r\n"
"// This instantiates tests from test case StlStringTest\r\n"
"// each with STL strings with values \"a\" and \"b\":\r\n"
"//\r\n"
"// ::std::vector< ::std::string> GetParameterStrings() {\r\n"
"//   ::std::vector< ::std::string> v;\r\n"
"//   v.push_back(\"a\");\r\n"
"//   v.push_back(\"b\");\r\n"
"//   return v;\r\n"
"// }\r\n"
"//\r\n"
"// INSTANTIATE_TEST_CASE_P(CharSequence,\r\n"
"//                         StlStringTest,\r\n"
"//                         ValuesIn(GetParameterStrings()));\r\n"
"//\r\n"
"//\r\n"
"// This will also instantiate tests from CharTest\r\n"
"// each with parameter values 'a' and 'b':\r\n"
"//\r\n"
"// ::std::list<char> GetParameterChars() {\r\n"
"//   ::std::list<char> list;\r\n"
"//   list.push_back('a');\r\n"
"//   list.push_back('b');\r\n"
"//   return list;\r\n"
"// }\r\n"
"// ::std::list<char> l = GetParameterChars();\r\n"
"// INSTANTIATE_TEST_CASE_P(CharSequence2,\r\n"
"//                         CharTest,\r\n"
"//                         ValuesIn(l.begin(), l.end()));\r\n"
"//\r\n"
"template <typename ForwardIterator>\r\n"
"internal::ParamGenerator<\r\n"
"  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\r\n"
"ValuesIn(ForwardIterator begin, ForwardIterator end) {\r\n"
"  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>\r\n"
"      ::value_type ParamType;\r\n"
"  return internal::ParamGenerator<ParamType>(\r\n"
"      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));\r\n"
"}\r\n"
"\r\n"
"template <typename T, size_t N>\r\n"
"internal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {\r\n"
"  return ValuesIn(array, array + N);\r\n"
"}\r\n"
"\r\n"
"template <class Container>\r\n"
"internal::ParamGenerator<typename Container::value_type> ValuesIn(\r\n"
"    const Container& container) {\r\n"
"  return ValuesIn(container.begin(), container.end());\r\n"
"}\r\n"
"\r\n"
"// Values() allows generating tests from explicitly specified list of\r\n"
"// parameters.\r\n"
"//\r\n"
"// Synopsis:\r\n"
"// Values(T v1, T v2, ..., T vN)\r\n"
"//   - returns a generator producing sequences with elements v1, v2, ..., vN.\r\n"
"//\r\n"
"// For example, this instantiates tests from test case BarTest each\r\n"
"// with values \"one\", \"two\", and \"three\":\r\n"
"//\r\n"
"// INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values(\"one\", \"two\", \"three\"));\r\n"
"//\r\n"
"// This instantiates tests from test case BazTest each with values 1, 2, 3.5.\r\n"
"// The exact type of values will depend on the type of parameter in BazTest.\r\n"
"//\r\n"
"// INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));\r\n"
"//\r\n"
"// Currently, Values() supports from 1 to $n parameters.\r\n"
"//\r\n"
"$range i 1..n\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"\r\n"
"template <$for j, [[typename T$j]]>\r\n"
"internal::ValueArray$i<$for j, [[T$j]]> Values($for j, [[T$j v$j]]) {\r\n"
"  return internal::ValueArray$i<$for j, [[T$j]]>($for j, [[v$j]]);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"// Bool() allows generating tests with parameters in a set of (false, true).\r\n"
"//\r\n"
"// Synopsis:\r\n"
"// Bool()\r\n"
"//   - returns a generator producing sequences with elements {false, true}.\r\n"
"//\r\n"
"// It is useful when testing code that depends on Boolean flags. Combinations\r\n"
"// of multiple flags can be tested when several Bool()'s are combined using\r\n"
"// Combine() function.\r\n"
"//\r\n"
"// In the following example all tests in the test case FlagDependentTest\r\n"
"// will be instantiated twice with parameters false and true.\r\n"
"//\r\n"
"// class FlagDependentTest : public testing::TestWithParam<bool> {\r\n"
"//   virtual void SetUp() {\r\n"
"//     external_flag = GetParam();\r\n"
"//   }\r\n"
"// }\r\n"
"// INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());\r\n"
"//\r\n"
"inline internal::ParamGenerator<bool> Bool() {\r\n"
"  return Values(false, true);\r\n"
"}\r\n"
"\r\n"
"# if GTEST_HAS_COMBINE\r\n"
"// Combine() allows the user to combine two or more sequences to produce\r\n"
"// values of a Cartesian product of those sequences' elements.\r\n"
"//\r\n"
"// Synopsis:\r\n"
"// Combine(gen1, gen2, ..., genN)\r\n"
"//   - returns a generator producing sequences with elements coming from\r\n"
"//     the Cartesian product of elements from the sequences generated by\r\n"
"//     gen1, gen2, ..., genN. The sequence elements will have a type of\r\n"
"//     tuple<T1, T2, ..., TN> where T1, T2, ..., TN are the types\r\n"
"//     of elements from sequences produces by gen1, gen2, ..., genN.\r\n"
"//\r\n"
"// Combine can have up to $maxtuple arguments. This number is currently limited\r\n"
"// by the maximum number of elements in the tuple implementation used by Google\r\n"
"// Test.\r\n"
"//\r\n"
"// Example:\r\n"
"//\r\n"
"// This will instantiate tests in test case AnimalTest each one with\r\n"
"// the parameter values tuple(\"cat\", BLACK), tuple(\"cat\", WHITE),\r\n"
"// tuple(\"dog\", BLACK), and tuple(\"dog\", WHITE):\r\n"
"//\r\n"
"// enum Color { BLACK, GRAY, WHITE };\r\n"
"// class AnimalTest\r\n"
"//     : public testing::TestWithParam<tuple<const char*, Color> > {...};\r\n"
"//\r\n"
"// TEST_P(AnimalTest, AnimalLooksNice) {...}\r\n"
"//\r\n"
"// INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,\r\n"
"//                         Combine(Values(\"cat\", \"dog\"),\r\n"
"//                                 Values(BLACK, WHITE)));\r\n"
"//\r\n"
"// This will instantiate tests in FlagDependentTest with all variations of two\r\n"
"// Boolean flags:\r\n"
"//\r\n"
"// class FlagDependentTest\r\n"
"//     : public testing::TestWithParam<tuple<bool, bool> > {\r\n"
"//   virtual void SetUp() {\r\n"
"//     // Assigns external_flag_1 and external_flag_2 values from the tuple.\r\n"
"//     tie(external_flag_1, external_flag_2) = GetParam();\r\n"
"//   }\r\n"
"// };\r\n"
"//\r\n"
"// TEST_P(FlagDependentTest, TestFeature1) {\r\n"
"//   // Test your code using external_flag_1 and external_flag_2 here.\r\n"
"// }\r\n"
"// INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,\r\n"
"//                         Combine(Bool(), Bool()));\r\n"
"//\r\n"
"$range i 2..maxtuple\r\n"
"$for i [[\r\n"
"$range j 1..i\r\n"
"\r\n"
"template <$for j, [[typename Generator$j]]>\r\n"
"internal::CartesianProductHolder$i<$for j, [[Generator$j]]> Combine(\r\n"
"    $for j, [[const Generator$j& g$j]]) {\r\n"
"  return internal::CartesianProductHolder$i<$for j, [[Generator$j]]>(\r\n"
"      $for j, [[g$j]]);\r\n"
"}\r\n"
"\r\n"
"]]\r\n"
"# endif  // GTEST_HAS_COMBINE\r\n"
"\r\n"
"\r\n"
"\r\n"
"# define TEST_P(test_case_name, test_name) \\\r\n"
"  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\r\n"
"      : public test_case_name { \\\r\n"
"   public: \\\r\n"
"    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {} \\\r\n"
"    virtual void TestBody(); \\\r\n"
"   private: \\\r\n"
"    static int AddToRegistry() { \\\r\n"
"      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\r\n"
"          GetTestCasePatternHolder<test_case_name>(\\\r\n"
"              #test_case_name, \\\r\n"
"              ::testing::internal::CodeLocation(\\\r\n"
"                  __FILE__, __LINE__))->AddTestPattern(\\\r\n"
"                      #test_case_name, \\\r\n"
"                      #test_name, \\\r\n"
"                      new ::testing::internal::TestMetaFactory< \\\r\n"
"                          GTEST_TEST_CLASS_NAME_(\\\r\n"
"                              test_case_name, test_name)>()); \\\r\n"
"      return 0; \\\r\n"
"    } \\\r\n"
"    static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \\\r\n"
"    GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\r\n"
"        GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \\\r\n"
"  }; \\\r\n"
"  int GTEST_TEST_CLASS_NAME_(test_case_name, \\\r\n"
"                             test_name)::gtest_registering_dummy_ = \\\r\n"
"      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \\\r\n"
"  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\r\n"
"\r\n"
"// The optional last argument to INSTANTIATE_TEST_CASE_P allows the user\r\n"
"// to specify a function or functor that generates custom test name suffixes\r\n"
"// based on the test parameters. The function should accept one argument of\r\n"
"// type testing::TestParamInfo<class ParamType>, and return std::string.\r\n"
"//\r\n"
"// testing::PrintToStringParamName is a builtin test suffix generator that\r\n"
"// returns the value of testing::PrintToString(GetParam()).\r\n"
"//\r\n"
"// Note: test names must be non-empty, unique, and may only contain ASCII\r\n"
"// alphanumeric characters or underscore. Because PrintToString adds quotes\r\n"
"// to std::string and C strings, it won't work for these types.\r\n"
"\r\n"
"# define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator, ...) \\\r\n"
"  ::testing::internal::ParamGenerator<test_case_name::ParamType> \\\r\n"
"      gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \\\r\n"
"  ::std::string gtest_##prefix##test_case_name##_EvalGenerateName_( \\\r\n"
"      const ::testing::TestParamInfo<test_case_name::ParamType>& info) { \\\r\n"
"    return ::testing::internal::GetParamNameGen<test_case_name::ParamType> \\\r\n"
"        (__VA_ARGS__)(info); \\\r\n"
"  } \\\r\n"
"  int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \\\r\n"
"      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\r\n"
"          GetTestCasePatternHolder<test_case_name>(\\\r\n"
"              #test_case_name, \\\r\n"
"              ::testing::internal::CodeLocation(\\\r\n"
"                  __FILE__, __LINE__))->AddTestCaseInstantiation(\\\r\n"
"                      #prefix, \\\r\n"
"                      &gtest_##prefix##test_case_name##_EvalGenerator_, \\\r\n"
"                      &gtest_##prefix##test_case_name##_EvalGenerateName_, \\\r\n"
"                      __FILE__, __LINE__)\r\n"
"\r\n"
"}  // namespace testing\r\n"
"\r\n"
"#endif  // GTEST_HAS_PARAM_TEST\r\n"
"\r\n"
"#endif  // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\r\n";

const char* gtestparamtest_h_pump = (const char*) temp_binary_data_39;


const char* getNamedResource (const char* resourceNameUTF8, int& numBytes);
const char* getNamedResource (const char* resourceNameUTF8, int& numBytes)
{
    unsigned int hash = 0;

    if (resourceNameUTF8 != nullptr)
        while (*resourceNameUTF8 != 0)
            hash = 31 * hash + (unsigned int) *resourceNameUTF8++;

    switch (hash)
    {
        case 0x71024ebe:  numBytes = 1252; return Cholesky;
        case 0xfe5a710f:  numBytes = 1948; return CholmodSupport;
        case 0x90e15cf5:  numBytes = 713; return CMakeLists_txt;
        case 0x002023bf:  numBytes = 18498; return Core;
        case 0x03edd2ff:  numBytes = 129; return Dense;
        case 0x03fda00c:  numBytes = 37; return Eigen;
        case 0x80f6042e:  numBytes = 1883; return Eigenvalues;
        case 0x71e26c92:  numBytes = 2112; return Geometry;
        case 0xd03464ac:  numBytes = 904; return Householder;
        case 0xcb4ed54e:  numBytes = 2131; return IterativeLinearSolvers;
        case 0x83cc338a:  numBytes = 972; return Jacobi;
        case 0x00000989:  numBytes = 1483; return LU;
        case 0x2ed44d09:  numBytes = 1026; return MetisSupport;
        case 0x20e2ff1e:  numBytes = 2556; return OrderingMethods;
        case 0x5790bfcd:  numBytes = 1151; return PardisoSupport;
        case 0xe4d2f3ae:  numBytes = 1724; return PaStiXSupport;
        case 0x00000a21:  numBytes = 1368; return QR;
        case 0xd49890e9:  numBytes = 985; return QtAlignedMalloc;
        case 0x93fa5640:  numBytes = 955; return Sparse;
        case 0x796264fe:  numBytes = 1416; return SparseCholesky;
        case 0xc68559ff:  numBytes = 2309; return SparseCore;
        case 0x7ebdcfc9:  numBytes = 1759; return SparseLU;
        case 0x7ebdd061:  numBytes = 1259; return SparseQR;
        case 0xc18be4b1:  numBytes = 1196; return SPQRSupport;
        case 0x54e6e25d:  numBytes = 824; return StdDeque;
        case 0xf23cb141:  numBytes = 752; return StdList;
        case 0x66a64526:  numBytes = 830; return StdVector;
        case 0x9831890b:  numBytes = 2307; return SuperLUSupport;
        case 0x00014241:  numBytes = 1680; return SVD;
        case 0x6ac119e8:  numBytes = 1422; return UmfPackSupport;
        case 0xff984b1f:  numBytes = 443; return gmockgeneratedactions_h_pump;
        case 0xd295fda8:  numBytes = 5062; return gmockgeneratedinternalutils_h_pump;
        case 0xf37118f3:  numBytes = 27195; return gmockgeneratedactions_h_pump2;
        case 0xd2640378:  numBytes = 9628; return gmockgeneratedfunctionmockers_h_pump;
        case 0x4aa3a65f:  numBytes = 22409; return gmockgeneratedmatchers_h_pump;
        case 0xa2a5f35a:  numBytes = 6195; return gmockgeneratednicestrict_h_pump;
        case 0x4de56945:  numBytes = 9393; return gtestparamutilgenerated_h_pump;
        case 0xf235582f:  numBytes = 9967; return gtesttuple_h_pump;
        case 0xf8255ca9:  numBytes = 9614; return gtesttypeutil_h_pump;
        case 0xda52dcf8:  numBytes = 20552; return gtestparamtest_h_pump;
        default: break;
    }

    numBytes = 0;
    return nullptr;
}

const char* namedResourceList[] =
{
    "Cholesky",
    "CholmodSupport",
    "CMakeLists_txt",
    "Core",
    "Dense",
    "Eigen",
    "Eigenvalues",
    "Geometry",
    "Householder",
    "IterativeLinearSolvers",
    "Jacobi",
    "LU",
    "MetisSupport",
    "OrderingMethods",
    "PardisoSupport",
    "PaStiXSupport",
    "QR",
    "QtAlignedMalloc",
    "Sparse",
    "SparseCholesky",
    "SparseCore",
    "SparseLU",
    "SparseQR",
    "SPQRSupport",
    "StdDeque",
    "StdList",
    "StdVector",
    "SuperLUSupport",
    "SVD",
    "UmfPackSupport",
    "gmockgeneratedactions_h_pump",
    "gmockgeneratedinternalutils_h_pump",
    "gmockgeneratedactions_h_pump2",
    "gmockgeneratedfunctionmockers_h_pump",
    "gmockgeneratedmatchers_h_pump",
    "gmockgeneratednicestrict_h_pump",
    "gtestparamutilgenerated_h_pump",
    "gtesttuple_h_pump",
    "gtesttypeutil_h_pump",
    "gtestparamtest_h_pump"
};

const char* originalFilenames[] =
{
    "Cholesky",
    "CholmodSupport",
    "CMakeLists.txt",
    "Core",
    "Dense",
    "Eigen",
    "Eigenvalues",
    "Geometry",
    "Householder",
    "IterativeLinearSolvers",
    "Jacobi",
    "LU",
    "MetisSupport",
    "OrderingMethods",
    "PardisoSupport",
    "PaStiXSupport",
    "QR",
    "QtAlignedMalloc",
    "Sparse",
    "SparseCholesky",
    "SparseCore",
    "SparseLU",
    "SparseQR",
    "SPQRSupport",
    "StdDeque",
    "StdList",
    "StdVector",
    "SuperLUSupport",
    "SVD",
    "UmfPackSupport",
    "gmock-generated-actions.h.pump",
    "gmock-generated-internal-utils.h.pump",
    "gmock-generated-actions.h.pump",
    "gmock-generated-function-mockers.h.pump",
    "gmock-generated-matchers.h.pump",
    "gmock-generated-nice-strict.h.pump",
    "gtest-param-util-generated.h.pump",
    "gtest-tuple.h.pump",
    "gtest-type-util.h.pump",
    "gtest-param-test.h.pump"
};

const char* getNamedResourceOriginalFilename (const char* resourceNameUTF8);
const char* getNamedResourceOriginalFilename (const char* resourceNameUTF8)
{
    for (unsigned int i = 0; i < (sizeof (namedResourceList) / sizeof (namedResourceList[0])); ++i)
    {
        if (namedResourceList[i] == resourceNameUTF8)
            return originalFilenames[i];
    }

    return nullptr;
}

}
